<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · SymmetryReduceBZ</title><meta name="title" content="Documentation · SymmetryReduceBZ"/><meta property="og:title" content="Documentation · SymmetryReduceBZ"/><meta property="twitter:title" content="Documentation · SymmetryReduceBZ"/><meta name="description" content="Documentation for SymmetryReduceBZ."/><meta property="og:description" content="Documentation for SymmetryReduceBZ."/><meta property="twitter:description" content="Documentation for SymmetryReduceBZ."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymmetryReduceBZ</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../Usage/">User guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jerjorg/SymmetryReduceBZ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/master/docs/src/Documentation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><h3 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Lattices.check_reduced-Tuple{AbstractMatrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.check_reduced</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_BCC"><code>SymmetryReduceBZ.Lattices.genlat_BCC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_BCT"><code>SymmetryReduceBZ.Lattices.genlat_BCT</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_CUB"><code>SymmetryReduceBZ.Lattices.genlat_CUB</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_FCC"><code>SymmetryReduceBZ.Lattices.genlat_FCC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_HEX"><code>SymmetryReduceBZ.Lattices.genlat_HEX</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_HXG"><code>SymmetryReduceBZ.Lattices.genlat_HXG</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_MCL"><code>SymmetryReduceBZ.Lattices.genlat_MCL</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_MCLC"><code>SymmetryReduceBZ.Lattices.genlat_MCLC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_OBL"><code>SymmetryReduceBZ.Lattices.genlat_OBL</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORC"><code>SymmetryReduceBZ.Lattices.genlat_ORC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORCC"><code>SymmetryReduceBZ.Lattices.genlat_ORCC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORCF"><code>SymmetryReduceBZ.Lattices.genlat_ORCF</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORCI"><code>SymmetryReduceBZ.Lattices.genlat_ORCI</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_REC"><code>SymmetryReduceBZ.Lattices.genlat_REC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_RECI"><code>SymmetryReduceBZ.Lattices.genlat_RECI</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_RHL"><code>SymmetryReduceBZ.Lattices.genlat_RHL</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_SQR"><code>SymmetryReduceBZ.Lattices.genlat_SQR</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_TET"><code>SymmetryReduceBZ.Lattices.genlat_TET</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_TRI"><code>SymmetryReduceBZ.Lattices.genlat_TRI</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.get_latparams-Tuple{AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.get_latparams</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.get_recip_latvecs"><code>SymmetryReduceBZ.Lattices.get_recip_latvecs</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.minkowski_reduce-Tuple{AbstractMatrix{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.minkowski_reduce</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.reduce_basis!-Tuple{AbstractMatrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real, Int64}"><code>SymmetryReduceBZ.Lattices.reduce_basis!</code></a></li></ul><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Plotting.plot_2Dconvexhull"><code>SymmetryReduceBZ.Plotting.plot_2Dconvexhull</code></a></li><li><a href="#SymmetryReduceBZ.Plotting.plot_3Dconvexhull"><code>SymmetryReduceBZ.Plotting.plot_3Dconvexhull</code></a></li><li><a href="#SymmetryReduceBZ.Plotting.plot_convexhulls"><code>SymmetryReduceBZ.Plotting.plot_convexhulls</code></a></li></ul><h3 id="Symmetry"><a class="docs-heading-anchor" href="#Symmetry">Symmetry</a><a id="Symmetry-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Symmetry.calc_bz"><code>SymmetryReduceBZ.Symmetry.calc_bz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.calc_ibz"><code>SymmetryReduceBZ.Symmetry.calc_ibz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.calc_pointgroup-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}"><code>SymmetryReduceBZ.Symmetry.calc_pointgroup</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.calc_spacegroup-Tuple{AbstractMatrix{var&quot;#s63&quot;} where var&quot;#s63&quot;&lt;:Real, AbstractVector{var&quot;#s62&quot;} where var&quot;#s62&quot;&lt;:Int64, AbstractMatrix{var&quot;#s61&quot;} where var&quot;#s61&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.calc_spacegroup</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.complete_orbit-Tuple{AbstractMatrix{var&quot;#s111&quot;} where var&quot;#s111&quot;&lt;:Real, AbstractVector{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:(AbstractMatrix{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:Real)}"><code>SymmetryReduceBZ.Symmetry.complete_orbit</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.complete_orbit-Tuple{AbstractVector{var&quot;#s111&quot;} where var&quot;#s111&quot;&lt;:Real, AbstractVector{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:(AbstractMatrix{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:Real)}"><code>SymmetryReduceBZ.Symmetry.complete_orbit</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.inhull-Tuple{Any, Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Symmetry.inhull</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.make_primitive-Tuple{AbstractMatrix{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:Real, AbstractVector{var&quot;#s107&quot;} where var&quot;#s107&quot;&lt;:Integer, AbstractMatrix{var&quot;#s106&quot;} where var&quot;#s106&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.make_primitive</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_bz-Tuple{AbstractVector{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, AbstractMatrix{var&quot;#s56&quot;} where var&quot;#s56&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_bz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_bz-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, AbstractMatrix{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_bz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_ibz"><code>SymmetryReduceBZ.Symmetry.mapto_ibz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_ibz-Tuple{AbstractVector{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:Real, AbstractMatrix{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractMatrix{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real, Any, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(AbstractMatrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), String}"><code>SymmetryReduceBZ.Symmetry.mapto_ibz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_unitcell-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, AbstractMatrix{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_unitcell</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_unitcell-Tuple{AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, AbstractMatrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_unitcell</code></a></li></ul><h3 id="Utilites"><a class="docs-heading-anchor" href="#Utilites">Utilites</a><a id="Utilites-1"></a><a class="docs-heading-anchor-permalink" href="#Utilites" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Utilities.affine_trans-Tuple{AbstractMatrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.affine_trans</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.contains-Tuple{AbstractArray, AbstractArray}"><code>SymmetryReduceBZ.Utilities.contains</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.contains-Tuple{AbstractVector{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real, AbstractMatrix{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.contains</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.edgelengths-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, Real}"><code>SymmetryReduceBZ.Utilities.edgelengths</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.get_uniquefacets</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.get_uniquefacetsindices-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.get_uniquefacetsindices</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.mapto_xyplane-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.mapto_xyplane</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.points_in_ball-Tuple{AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, Real, AbstractVector{var&quot;#s56&quot;} where var&quot;#s56&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.points_in_ball</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.remove_duplicates-Tuple{AbstractVector{T} where T}"><code>SymmetryReduceBZ.Utilities.remove_duplicates</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sample_circle"><code>SymmetryReduceBZ.Utilities.sample_circle</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sample_sphere"><code>SymmetryReduceBZ.Utilities.sample_sphere</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.shoelace-Tuple{AbstractMatrix{var&quot;#s63&quot;} where var&quot;#s63&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.shoelace</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sortpts2D-Tuple{AbstractMatrix{var&quot;#s62&quot;} where var&quot;#s62&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.sortpts2D</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sortpts_perm-Tuple{AbstractMatrix{var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.sortpts_perm</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.unique_points-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.unique_points</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.vertices-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.vertices</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.volume-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.volume</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="Lattices-2"><a class="docs-heading-anchor" href="#Lattices-2">Lattices</a><a class="docs-heading-anchor-permalink" href="#Lattices-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.check_reduced-Tuple{AbstractMatrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real}" href="#SymmetryReduceBZ.Lattices.check_reduced-Tuple{AbstractMatrix{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.check_reduced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_reduced(basis)</code></pre><p>Verify a lattice basis is Minkowski reduced</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: the lattice basis given by the columns   of a 2x2 or 3x3 matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: a boolean that indicates if the lattice basis is reduced.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis = [1 0; 0 1]
SymmetryReduceBZ.Lattices.check_reduced(basis)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L216-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_BCC" href="#SymmetryReduceBZ.Lattices.genlat_BCC"><code>SymmetryReduceBZ.Lattices.genlat_BCC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_BCC(a)</code></pre><p>Generate a body-centered cubic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_BCC(a)
# output
3×3 Matrix{Float64}:
 -0.5   0.5   0.5
  0.5  -0.5   0.5
  0.5   0.5  -0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L501-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_BCT" href="#SymmetryReduceBZ.Lattices.genlat_BCT"><code>SymmetryReduceBZ.Lattices.genlat_BCT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_BCT(a,c)</code></pre><p>Generate a body-centered tetragonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
c=1.2;
SymmetryReduceBZ.Lattices.genlat_BCT(a,c)
# output
3×3 Matrix{Float64}:
 -0.5   0.5   0.5
  0.5  -0.5   0.5
  0.6   0.6  -0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L573-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_CUB" href="#SymmetryReduceBZ.Lattices.genlat_CUB"><code>SymmetryReduceBZ.Lattices.genlat_CUB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_CUB(a)</code></pre><p>Generate a simple cubic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_CUB(a)
# output
3×3 Matrix{Int64}:
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L436-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_FCC" href="#SymmetryReduceBZ.Lattices.genlat_FCC"><code>SymmetryReduceBZ.Lattices.genlat_FCC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_FCC(a)</code></pre><p>Generate a face-centered cubic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_FCC(a)
# output
3×3 Matrix{Float64}:
 0.0  0.5  0.5
 0.5  0.0  0.5
 0.5  0.5  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L465-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_HEX" href="#SymmetryReduceBZ.Lattices.genlat_HEX"><code>SymmetryReduceBZ.Lattices.genlat_HEX</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_HEX(a,c)</code></pre><p>Generate a hexagonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
c=1.2;
SymmetryReduceBZ.Lattices.genlat_HEX(a,c)
# output
3×3 Matrix{Float64}:
  0.5       0.5       0.0
 -0.866025  0.866025  0.0
  0.0       0.0       1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L792-L818">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_HXG" href="#SymmetryReduceBZ.Lattices.genlat_HXG"><code>SymmetryReduceBZ.Lattices.genlat_HXG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_HXG(a)</code></pre><p>Generate a 2D hexagonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_HXG(a)
# output
2×2 Matrix{Float64}:
 1.0  -0.5
 0.0   0.866025</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L295-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_MCL" href="#SymmetryReduceBZ.Lattices.genlat_MCL"><code>SymmetryReduceBZ.Lattices.genlat_MCL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_MCL(a,b,c,α)</code></pre><p>Generate a monoclinic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians less than π/2</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2
c=1.4
α=π/6;
SymmetryReduceBZ.Lattices.genlat_MCL(a,b,c,α)
# output
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.2  1.21244
 0.0  0.0  0.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L865-L895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_MCLC" href="#SymmetryReduceBZ.Lattices.genlat_MCLC"><code>SymmetryReduceBZ.Lattices.genlat_MCLC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_MCLC(a,b,c,α)</code></pre><p>Generate a base-centered monoclinic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians less than π/2</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2
c=1.4
α=π/6;
SymmetryReduceBZ.Lattices.genlat_MCLC(a,b,c,α)
# output
3×3 Matrix{Float64}:
 0.5  -0.5  0.0
 0.6   0.6  1.21244
 0.0   0.0  0.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L908-L938">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_OBL" href="#SymmetryReduceBZ.Lattices.genlat_OBL"><code>SymmetryReduceBZ.Lattices.genlat_OBL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_OBL(a,b,θ)</code></pre><p>Generate an oblique lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>b::Real</code>: the lattice constant</li><li><code>θ::Real</code>: the lattice angle</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2
θ=π/3
SymmetryReduceBZ.Lattices.genlat_OBL(a,b,θ)
# output
2×2 Matrix{Float64}:
 1.0  0.6
 0.0  1.03923</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L395-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORC" href="#SymmetryReduceBZ.Lattices.genlat_ORC"><code>SymmetryReduceBZ.Lattices.genlat_ORC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_ORC(a,b,c)</code></pre><p>Generate an orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.4;
c=1.2;
SymmetryReduceBZ.Lattices.genlat_ORC(a,b,c)
# output
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.4  0.0
 0.0  0.0  1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L616-L644">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORCC" href="#SymmetryReduceBZ.Lattices.genlat_ORCC"><code>SymmetryReduceBZ.Lattices.genlat_ORCC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_ORCC(a,b,c)</code></pre><p>Generate a base-centered orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2;
c=1.4;
SymmetryReduceBZ.Lattices.genlat_ORCC(a,b,c)
# output
3×3 Matrix{Float64}:
  0.5  0.5  0.0
 -0.6  0.6  0.0
  0.0  0.0  1.4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L746-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORCF" href="#SymmetryReduceBZ.Lattices.genlat_ORCF"><code>SymmetryReduceBZ.Lattices.genlat_ORCF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_ORCF(a,b,c)</code></pre><p>Generate a face-centered orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.4;
c=1.2;
SymmetryReduceBZ.Lattices.genlat_ORCF(a,b,c)
# output
3×3 Matrix{Float64}:
 0.0  0.5  0.5
 0.7  0.0  0.7
 0.6  0.6  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L654-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORCI" href="#SymmetryReduceBZ.Lattices.genlat_ORCI"><code>SymmetryReduceBZ.Lattices.genlat_ORCI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_ORCI(a,b,c)</code></pre><p>Generate a body-centered orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.4;
c=1.2;
SymmetryReduceBZ.Lattices.genlat_ORCI(a,b,c)
# output
3×3 Matrix{Float64}:
 -0.5   0.5   0.5
  0.7  -0.7   0.7
  0.6   0.6  -0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L700-L728">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_REC" href="#SymmetryReduceBZ.Lattices.genlat_REC"><code>SymmetryReduceBZ.Lattices.genlat_REC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_REC(a,b)</code></pre><p>Generate a rectangular lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2
SymmetryReduceBZ.Lattices.genlat_REC(a,b)
# output
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L323-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_RECI" href="#SymmetryReduceBZ.Lattices.genlat_RECI"><code>SymmetryReduceBZ.Lattices.genlat_RECI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_RECI(a,b)</code></pre><p>Generate a body-centered rectangular lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2
SymmetryReduceBZ.Lattices.genlat_RECI(a,b)
# output
2×2 Matrix{Float64}:
  0.5  0.5
 -0.6  0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L353-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_RHL" href="#SymmetryReduceBZ.Lattices.genlat_RHL"><code>SymmetryReduceBZ.Lattices.genlat_RHL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_RHL(a,α)</code></pre><p>Generate a rhombohedral lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
α=π/6;
SymmetryReduceBZ.Lattices.genlat_RHL(a,α)
# output
3×3 Matrix{Float64}:
  0.965926  0.965926  0.896575
 -0.258819  0.258819  0.0
  0.0       0.0       0.442891</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L828-L854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_SQR" href="#SymmetryReduceBZ.Lattices.genlat_SQR"><code>SymmetryReduceBZ.Lattices.genlat_SQR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_SQR(a)</code></pre><p>Generate a square lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_SQR(a)
# output
2×2 Matrix{Int64}:
 1  0
 0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L267-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_TET" href="#SymmetryReduceBZ.Lattices.genlat_TET"><code>SymmetryReduceBZ.Lattices.genlat_TET</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_TET(a,c)</code></pre><p>Generate a simple tetragonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
c=1.2;
SymmetryReduceBZ.Lattices.genlat_TET(a,c)
# output
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L537-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_TRI" href="#SymmetryReduceBZ.Lattices.genlat_TRI"><code>SymmetryReduceBZ.Lattices.genlat_TRI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlat_TRI(a,b,c,α,β,γ)</code></pre><p>Generate a triclinic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians</li><li><code>β::Real</code>: a lattice angle in radians</li><li><code>γ::Real</code>: a lattice angle in radians</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
a=1
b=1.2
c=1.4
α=π/6;
β=π/3;
γ=π/4;
SymmetryReduceBZ.Lattices.genlat_TRI(a,b,c,α,β,γ)
# output
3×3 Matrix{Float64}:
 1.0  0.848528  0.7
 0.0  0.848528  1.01464
 0.0  0.0       0.663702</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L958-L992">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.get_latparams-Tuple{AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}" href="#SymmetryReduceBZ.Lattices.get_latparams-Tuple{AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.get_latparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_latparams(latvecs)</code></pre><p>Calculate the lattice constants and angles of a lattice basis.</p><p><strong>Arguments</strong></p><ul><li><code>latvecs::AbstractMatrix{&lt;:Real}</code>: the lattice basis as columns of an array.</li></ul><p><strong>Returns</strong></p><ul><li>A list where the first element is a list lattice constants <code>(a,b,c)</code> and second   lattice angles in radians <code>(α,β,γ)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
latvecs = [1 0; 0 1]
SymmetryReduceBZ.Lattices.get_latparams(latvecs)
# output
2-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [1.5707963267948966, 1.5707963267948966]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L56-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.get_recip_latvecs" href="#SymmetryReduceBZ.Lattices.get_recip_latvecs"><code>SymmetryReduceBZ.Lattices.get_recip_latvecs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_recip_latvecs(real_latvecs, convention)</code></pre><p>Calculate the reciprocal lattice vectors.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractMatrix{&lt;:Real}</code>: the real-space lattice vectors or   primitive translation vectors as columns of a 2x2 or 3x3 array.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li></ul><p><strong>Returns</strong></p><ul><li><code>recip_latvecs::Array{&lt;:Real,2}</code> the reciprocal lattice vectors (reciprocal   primitive translation vectors) as columns of a 2x2 or 3x3 array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
real_latvecs=[1 0 0; 0 1 0; 0 0 1]
convention=&quot;angular&quot;
SymmetryReduceBZ.Lattices.get_recip_latvecs(real_latvecs,convention)
# output
3×3 Matrix{Float64}:
 6.28319  0.0      0.0
 0.0      6.28319  0.0
 0.0      0.0      6.28319</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.minkowski_reduce-Tuple{AbstractMatrix{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}" href="#SymmetryReduceBZ.Lattices.minkowski_reduce-Tuple{AbstractMatrix{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.minkowski_reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minkowski_reduce(basis;rtol,atol)</code></pre><p>Minkowski reduce a lattice basis. Follows the logic of Fig. 4 in &quot;Low-Dimensional Lattice Basis Reduction Revisited&quot; by Nguyen, 2009.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: the lattice basis given by the columns   of a 2x2 or 3x3 array.</li><li><code>rtol::Real=sqrt(eps(float(maximum(basis))))</code>: a relative tolerance.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>rbasis</code>:: the Minkowski reduced lattice basis as columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis = [1 2 0; 0 1 0; 0 0 1]
SymmetryReduceBZ.Lattices.minkowski_reduce(basis)
# output
3×3 Matrix{Int64}:
 0  1  0
 0  0  1
 1  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L175-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.reduce_basis!-Tuple{AbstractMatrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real, Int64}" href="#SymmetryReduceBZ.Lattices.reduce_basis!-Tuple{AbstractMatrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real, Int64}"><code>SymmetryReduceBZ.Lattices.reduce_basis!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_basis!(basis,k;rtol,atol)</code></pre><p>Reduces the <code>k</code>th lattice vector. This is accomplished by locating the lattice point closest to the projection of the <code>k</code>th lattice vector onto the line or plane given by the other lattice vector(s), subtracting the closest lattice point from the <code>k</code>th lattice vector, and reordering the lattice vectors by increasing Euclidean norms.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: the lattice basis as columns of an array.</li><li><code>k::Int</code>: Keeps track of which lattice vector needs to be reduced.</li><li><code>rtol::Real=sqrt(eps(float(maximum(basis))))</code>: a relative tolerance.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: the partially reduced lattice basis as   columns of an array.</li><li><code>k::Int</code>: The index of the lattice vector that needs to be reduced next.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis = Array([1 2 0; 0 1 0; 3 2 1]&#39;)
k=2
SymmetryReduceBZ.Lattices.reduce_basis!(basis,k)
basis
# output
3×3 Matrix{Int64}:
 0  1  3
 1  2  2
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L96-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.lattice_types" href="#SymmetryReduceBZ.Lattices.lattice_types"><code>SymmetryReduceBZ.Lattices.lattice_types</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A list of lattice types. Follows the naming convention in the article High-throughput electronic band structure calculations: Challenges and tools by Wahyu Setyawan and Stefano Curtarolo except triclinic lattices have &quot;β&quot; instead of &quot;b&quot; as subscripts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Lattices.jl#L1008-L1012">source</a></section></article><h3 id="Plotting-2"><a class="docs-heading-anchor" href="#Plotting-2">Plotting</a><a class="docs-heading-anchor-permalink" href="#Plotting-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Plotting.plot_2Dconvexhull" href="#SymmetryReduceBZ.Plotting.plot_2Dconvexhull"><code>SymmetryReduceBZ.Plotting.plot_2Dconvexhull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_2Dconvexhull(convexhull, ax, color)</code></pre><p>Plot a 2D convex hull</p><div class="admonition is-info"><header class="admonition-header">Julia 1.9 and above</header><div class="admonition-body"><p>This function is implemented in a package extension and requires <code>using PyPlot</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>convexhull</code>: a polyhedron or convex hull object.</li><li><code>ax::PyObject</code>: an axes object from matplotlib.</li><li><code>facecolor::String=&quot;blue&quot;</code>: the color of the area within the convex hull.</li><li><code>alpha::Real=0.3</code>: the transparency of the convex hull.</li><li><code>linewidth::Real=3</code>: the width of the edges.</li><li><code>edgecolor::String=&quot;black&quot;</code>: the color of the edges.</li></ul><p><strong>Returns</strong></p><ul><li><code>ax::PyObject</code>: updated <code>ax</code> that includes a plot of the convex hull.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ENV[&quot;MPLBACKEND&quot;]=&quot;qt5agg&quot;
using PyPlot
using SymmetryReduceBZ.Symmetry: calc_bz, calc_ibz
using SymmetryReduceBZ.Plotting: plot_2Dconvexhull
real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coords = &quot;Cartesian&quot;
makeprim=false
bz = calc_bz(real_latvecs,atom_types,atom_pos,coords,makeprim,convention)
ibz = calc_ibz(real_latvecs,atom_types,atom_pos,coords,makeprim,convention)
ax = plot_2Dconvexhull(bz,facecolor=&quot;deepskyblue&quot;,linewidth=3,edgecolor=&quot;cyan&quot;,alpha=0.2)
ax = plot_2Dconvexhull(ibz,ax;facecolor=&quot;coral&quot;,linewidth=3,edgecolor=&quot;magenta&quot;,alpha=0.4)
# output
PyObject &lt;AxesSubplot: &gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Plotting.jl#L5-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Plotting.plot_3Dconvexhull" href="#SymmetryReduceBZ.Plotting.plot_3Dconvexhull"><code>SymmetryReduceBZ.Plotting.plot_3Dconvexhull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_3Dconvexhull(convexhull,ax;color)</code></pre><p>Plot a 3D convex hull</p><div class="admonition is-info"><header class="admonition-header">Julia 1.9 and above</header><div class="admonition-body"><p>This function is implemented in a package extension and requires <code>using PyPlot</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>convexhull</code>: a polyhedron or convex hull object.</li><li><code>ax::PyObject</code>: an axes object from matplotlib.</li><li><code>facecolors::String=&quot;blue&quot;</code>: the color of the faces of the convex hull.</li><li><code>alpha::Real=0.3</code>: the transparency of the faces of the convex hull.</li><li><code>linewidths::Real=1</code>: the width of the edges of the convex hull.</li><li><code>edgecolors::String=&quot;black&quot;</code>: the color of the edges of the convex hull.</li></ul><p><strong>Returns</strong></p><ul><li><code>ax::PyObject</code>: updated <code>ax</code> that includes a plot of the convex hull.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ENV[&quot;MPLBACKEND&quot;]=&quot;qt5agg&quot;
using PyPlot
using SymmetryReduceBZ.Symmetry: calc_bz, calc_ibz
using SymmetryReduceBZ.Plotting: plot_3Dconvexhull
real_latvecs = [1 0 0; 0 1 0; 0 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0 0]&#39;)
coords = &quot;Cartesian&quot;
makeprim=false
bz = calc_bz(real_latvecs,atom_types,atom_pos,coords,makeprim,convention)
ibz = calc_ibz(real_latvecs,atom_types,atom_pos,coords,makeprim,convention)
using3D()
fig = figure()
ax = fig.add_subplot(111, projection=&quot;3d&quot;)
ax = plot_3Dconvexhull(ibz,ax,facecolors=&quot;coral&quot;,alpha=1,edgecolors=&quot;black&quot;,linewidths = 1)
ax = plot_3Dconvexhull(bz,ax,facecolors=&quot;deepskyblue&quot;,edgecolors=&quot;white&quot;,linewidths=1,alpha=0.2)
# output
PyObject &lt;Axes3DSubplot: &gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Plotting.jl#L46-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Plotting.plot_convexhulls" href="#SymmetryReduceBZ.Plotting.plot_convexhulls"><code>SymmetryReduceBZ.Plotting.plot_convexhulls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_convexhulls(real_latvecs,atom_types,atom_pos,coords,makeprim,convention;rtol,atol)</code></pre><p>Plot the Brillouin and Irreducible Brillouin zone in 2D or 3D.</p><div class="admonition is-info"><header class="admonition-header">Julia 1.9 and above</header><div class="admonition-body"><p>This function is implemented in a package extension and requires <code>using PyPlot</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractMatrix{&lt;:Real}</code>: the basis of a real-space lattice as   columns of a matrix.</li><li><code>atom_types:AbstractVector{&lt;:Int}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractMatrix{&lt;:Real}</code>: the positions of atoms in the crystal   structure as columns of a matrix.</li><li><code>coords::String</code>: indicates the positions of the atoms are in &quot;lattice&quot; or   &quot;Cartesian&quot; coordinates.</li><li><code>makeprim::Bool=false</code>: make the unit cell primitive before calculating the   the IBZ if equal to <code>true</code>.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li><li><code>library::Polyhedra.Library=CDDLib.Library()</code>: a polyhedron manipulation library</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>ax::PyObject</code>: an updated <code>ax</code> with plots of the BZ and IBZ.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ENV[&quot;MPLBACKEND&quot;]=&quot;qt5agg&quot;
using PyPlot
using SymmetryReduceBZ
real_latvecs = [1 0; .5 1]
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coords = &quot;Cartesian&quot;
makeprim = true
convention = &quot;ordinary&quot;
ax=plot_convexhulls(real_latvecs,atom_types,atom_pos,coords,makeprim,convention)
# output
PyObject &lt;AxesSubplot: &gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Plotting.jl#L90-L135">source</a></section></article><h3 id="Symmetry-2"><a class="docs-heading-anchor" href="#Symmetry-2">Symmetry</a><a class="docs-heading-anchor-permalink" href="#Symmetry-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_bz" href="#SymmetryReduceBZ.Symmetry.calc_bz"><code>SymmetryReduceBZ.Symmetry.calc_bz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_bz(real_latvecs,atom_types,atom_pos,coordinates,bzformat,makeprim,
    convention,library;rtol,atol)</code></pre><p>Calculate the Brillouin zone for the given real-space lattice basis.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractMatrix{&lt;:Real}</code>: the real-space lattice vectors or   primitive translation vectors as columns of a 2x2 or 3x3 matrix.</li><li><code>atom_typesAbstractVector{&lt;:Int}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractMatrix{&lt;:Real}</code>: the positions of atoms in the crystal   structure as columns of a matrix.</li><li><code>coordinates::String</code>: indicates the positions of the atoms are in &quot;lattice&quot;   or &quot;Cartesian&quot; coordinates.</li><li><code>bzformat::String</code>: the format of the Brillouin zone. Options include   &quot;convex hull&quot; and &quot;half-space&quot;.</li><li><code>makeprim::Bool=false</code>: make the unit cell primitive before calculating the   the BZ if equal to <code>true</code>.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li><li><code>library::Polyhedra.Library=CDDLib.Library()</code>: a polyhedron manipulation library</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>bz</code>: a polyhedron conforming to the Polyhedra.jl interface that represents the convex hull of the Brillouin zone.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coordinates = &quot;Cartesian&quot;
makeprim=false
SymmetryReduceBZ.Symmetry.calc_bz(real_latvecs,atom_types,atom_pos,coordinates,
    makeprim,convention)
# output
Polyhedron CDDLib.Polyhedron{Float64}:
25-element iterator of Polyhedra.HalfSpace{Float64, Vector{Float64}}:
 HalfSpace([-2.0, -2.0], 4.0)
 HalfSpace([-2.0, -1.0], 2.5)
 HalfSpace([-2.0, 0.0], 2.0)
 HalfSpace([-2.0, 1.0], 2.5)
 HalfSpace([-2.0, 2.0], 4.0)
 HalfSpace([-1.0, -2.0], 2.5)
 HalfSpace([-1.0, -1.0], 1.0)
 HalfSpace([-1.0, 0.0], 0.5)
 HalfSpace([-1.0, 1.0], 1.0)
 HalfSpace([-1.0, 2.0], 2.5)
 HalfSpace([0.0, -2.0], 2.0)
 HalfSpace([0.0, -1.0], 0.5)
 HalfSpace([0.0, 0.0], 0.0)
 HalfSpace([0.0, 1.0], 0.5)
 HalfSpace([0.0, 2.0], 2.0)
 HalfSpace([1.0, -2.0], 2.5)
 HalfSpace([1.0, -1.0], 1.0)
 HalfSpace([1.0, 0.0], 0.5)
 HalfSpace([1.0, 1.0], 1.0)
 HalfSpace([1.0, 2.0], 2.5)
  ⋮:
4-element iterator of Vector{Float64}:
 [0.5, 0.5]
 [0.5, -0.5]
 [-0.5, -0.5]
 [-0.5, 0.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L479-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_ibz" href="#SymmetryReduceBZ.Symmetry.calc_ibz"><code>SymmetryReduceBZ.Symmetry.calc_ibz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_ibz(real_latvecs,atom_types,atom_pos,coordinates,ibzformat,makeprim,
    convention,library;rtol,atol)</code></pre><p>Calculate the irreducible Brillouin zone of a crystal structure in 2D or 3D.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractMatrix{&lt;:Real}</code>: the basis of a real-space lattice as   columns of a matrix.</li><li><code>atom_types:AbstractVector{&lt;:Int}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractMatrix{&lt;:Real}</code>: the positions of atoms in the crystal   structure as columns of a matrix.</li><li><code>coordinates::String</code>: indicates the positions of the atoms are in &quot;lattice&quot;   or &quot;Cartesian&quot; coordinates.</li><li><code>ibzformat::String</code>: the format of the irreducible Brillouin zone. Options   include &quot;convex hull&quot; and &quot;half-space&quot;.</li><li><code>makeprim::Bool=false</code>: make the unit cell primitive before calculating the   IBZ if true.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li><li><code>library::Polyhedra.Library=CDDLib.Library()</code>: a polyhedron manipulation library</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>ibz</code>: the irreducible Brillouin zone as a polyhedron conforming to the Polyhedra.jl interface.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coordinates = &quot;Cartesian&quot;
makeprim=false
SymmetryReduceBZ.Symmetry.calc_ibz(real_latvecs,atom_types,atom_pos,coordinates,
    makeprim,convention)
# output
Polyhedron CDDLib.Polyhedron{Float64}:
32-element iterator of Polyhedra.HalfSpace{Float64, Vector{Float64}}:
 HalfSpace([-2.0, -2.0], 4.0)
 HalfSpace([-2.0, -1.0], 2.5)
 HalfSpace([-2.0, 0.0], 2.0)
 HalfSpace([-2.0, 1.0], 2.5)
 HalfSpace([-2.0, 2.0], 4.0)
 HalfSpace([-1.0, -2.0], 2.5)
 HalfSpace([-1.0, -1.0], 1.0)
 HalfSpace([-1.0, 0.0], 0.5)
 HalfSpace([-1.0, 1.0], 1.0)
 HalfSpace([-1.0, 2.0], 2.5)
 HalfSpace([0.0, -2.0], 2.0)
 HalfSpace([0.0, -1.0], 0.5)
 HalfSpace([0.0, 0.0], 0.0)
 HalfSpace([0.0, 1.0], 0.5)
 HalfSpace([0.0, 2.0], 2.0)
 HalfSpace([1.0, -2.0], 2.5)
 HalfSpace([1.0, -1.0], 1.0)
 HalfSpace([1.0, 0.0], 0.5)
 HalfSpace([1.0, 1.0], 1.0)
 HalfSpace([1.0, 2.0], 2.5)
  ⋮:
3-element iterator of Vector{Float64}:
 [0.0, 0.0]
 [0.5, 0.0]
 [0.5, 0.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L579-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_pointgroup-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}" href="#SymmetryReduceBZ.Symmetry.calc_pointgroup-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}"><code>SymmetryReduceBZ.Symmetry.calc_pointgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_pointgroup(latvecs;rtol,atol)</code></pre><p>Calculate the point group of a lattice in 2D or 3D.</p><p><strong>Arguments</strong></p><ul><li><code>latvecs::AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as columns of a   matrix.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code>: a relative tolerance for   floating point comparisons. It is used to compare lengths of vectors and the   volumes of primitive cells.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons. It is   used to compare lengths of vectors and the volumes of primitive cells.</li></ul><p><strong>Returns</strong></p><ul><li><code>pointgroup::AbstractVector{&lt;:AbstractMatrix{&lt;:Real}}</code>: the point group of the lattice. The   operators operate on points in Cartesian coordinates from the right.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis = [1 0; 0 1]
SymmetryReduceBZ.Symmetry.calc_pointgroup(basis)
# output
8-element Vector{Matrix{Float64}}:
 [0.0 -1.0; -1.0 0.0]
 [0.0 -1.0; 1.0 0.0]
 [-1.0 0.0; 0.0 -1.0]
 [1.0 0.0; 0.0 -1.0]
 [-1.0 0.0; 0.0 1.0]
 [1.0 0.0; 0.0 1.0]
 [0.0 1.0; -1.0 0.0]
 [0.0 1.0; 1.0 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L12-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_spacegroup-Tuple{AbstractMatrix{var&quot;#s63&quot;} where var&quot;#s63&quot;&lt;:Real, AbstractVector{var&quot;#s62&quot;} where var&quot;#s62&quot;&lt;:Int64, AbstractMatrix{var&quot;#s61&quot;} where var&quot;#s61&quot;&lt;:Real, String}" href="#SymmetryReduceBZ.Symmetry.calc_spacegroup-Tuple{AbstractMatrix{var&quot;#s63&quot;} where var&quot;#s63&quot;&lt;:Real, AbstractVector{var&quot;#s62&quot;} where var&quot;#s62&quot;&lt;:Int64, AbstractMatrix{var&quot;#s61&quot;} where var&quot;#s61&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.calc_spacegroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_spacegroup(real_latvecs,atom_types,atom_pos,coordinates;rtol,atol)</code></pre><p>Calculate the space group of a crystal structure.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as columns   of a matrix.</li><li><code>atom_types::AbstractVector{&lt;:Int}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractMatrix{&lt;:Real}</code>: the positions of atoms in the crystal   structure as columns of a matrix.</li><li><code>coordinates::String</code>: indicates the positions of the atoms are in &quot;lattice&quot;   or &quot;Cartesian&quot; coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>spacegroup::Tuple</code>: the space group of the crystal structure. The first element of   <code>spacegroup</code> is a list of fractional translations, and the second element is   a list of point operators. The translations are in Cartesian coordinates,   and the operators operate on points in Cartesian coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
real_latvecs = Array([1 0; 2 1]&#39;)
atom_types = [0, 1]
atom_pos = Array([0 0; 0.5 0.5]&#39;)
coordinates = &quot;Cartesian&quot;
SymmetryReduceBZ.Symmetry.calc_spacegroup(real_latvecs,atom_types,atom_pos,
    coordinates)
# output
([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]], [[0.0 -1.0; -1.0 0.0], [0.0 -1.0; 1.0 0.0], [-1.0 0.0; 0.0 -1.0], [1.0 0.0; 0.0 -1.0], [-1.0 0.0; 0.0 1.0], [1.0 0.0; 0.0 1.0], [0.0 1.0; -1.0 0.0], [0.0 1.0; 1.0 0.0]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L378-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.complete_orbit-Tuple{AbstractMatrix{var&quot;#s111&quot;} where var&quot;#s111&quot;&lt;:Real, AbstractVector{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:(AbstractMatrix{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:Real)}" href="#SymmetryReduceBZ.Symmetry.complete_orbit-Tuple{AbstractMatrix{var&quot;#s111&quot;} where var&quot;#s111&quot;&lt;:Real, AbstractVector{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:(AbstractMatrix{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:Real)}"><code>SymmetryReduceBZ.Symmetry.complete_orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complete_orbit(pt,pointgroup,rtol=sqrt(eps(float(maximum(pt)))),atol=1e-9)</code></pre><p>Complete the orbits of multiple points.</p><p><strong>Arguments</strong></p><ul><li><code>pt::AbstractMatrix{&lt;:Real}</code>: the Cartesian coordinates of a points as columns of   a matrix.</li><li><code>pointgroup::AbstractVector{&lt;:AbstractMatrix{&lt;:Real}}</code>: the point group operators   in a nested list. The operators operate on points in Cartesian coordinates from the right.</li><li><code>rtol::Real=sqrt(eps(float(maximum(pt))))</code>: a relative tolerance.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::AbstractMatrix{&lt;:Real}</code>: the unique points of the orbits in Cartesian coordinates as   columns of a matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import SymmetryReduceBZ.Symmetry: complete_orbit
pts = [0.0 0.05 0.1; 0.0 0.0 0.0]
pointgroup = [[0.0 -1.0; -1.0 0.0], [0.0 -1.0; 1.0 0.0], [-1.0 0.0; 0.0 -1.0], [1.0 0.0; 0.0 -1.0], [-1.0 0.0; 0.0 1.0], [1.0 0.0; 0.0 1.0], [0.0 1.0; -1.0 0.0], [0.0 1.0; 1.0 0.0]]
complete_orbit(pts,pointgroup)
# output
2×9 Matrix{Float64}:
 0.0   0.0   0.0   -0.05  0.05   0.0  0.0  -0.1  0.1
 0.0  -0.05  0.05   0.0   0.0   -0.1  0.1   0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L871-L899">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.complete_orbit-Tuple{AbstractVector{var&quot;#s111&quot;} where var&quot;#s111&quot;&lt;:Real, AbstractVector{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:(AbstractMatrix{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:Real)}" href="#SymmetryReduceBZ.Symmetry.complete_orbit-Tuple{AbstractVector{var&quot;#s111&quot;} where var&quot;#s111&quot;&lt;:Real, AbstractVector{var&quot;#s110&quot;} where var&quot;#s110&quot;&lt;:(AbstractMatrix{var&quot;#s109&quot;} where var&quot;#s109&quot;&lt;:Real)}"><code>SymmetryReduceBZ.Symmetry.complete_orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complete_orbit(pt,pointgroup,rtol=sqrt(eps(float(maximum(pt)))),atol=1e-9)</code></pre><p>Complete the orbit of a point.</p><p><strong>Arguments</strong></p><ul><li><code>pt::AbstractVector{&lt;:Real}</code>: the Cartesian coordinates of a point.</li><li><code>pointgroup::AbstractVector{&lt;:AbstractMatrix{&lt;:Real}}</code>: the point group operators   in a nested list. The operators operate on points in Cartesian coordinates   from the right.</li><li><code>rtol::Real=sqrt(eps(float(maximum(pt))))</code>: a relative tolerance.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::AbstractMatrix{&lt;:Real}</code>: the points of the orbit in Cartesian coordinates as   columns of a matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import SymmetryReduceBZ.Symmetry: complete_orbit
pt = [0.05, 0.0]
pointgroup = [[0.0 -1.0; -1.0 0.0], [0.0 -1.0; 1.0 0.0], [-1.0 0.0; 0.0 -1.0], [1.0 0.0; 0.0 -1.0], [-1.0 0.0; 0.0 1.0], [1.0 0.0; 0.0 1.0], [0.0 1.0; -1.0 0.0], [0.0 1.0; 1.0 0.0]]
complete_orbit(pt,pointgroup)
# output
2×4 Matrix{Float64}:
  0.0   0.0   -0.05  0.05
 -0.05  0.05   0.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L835-L863">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.inhull-Tuple{Any, Polyhedra.Polyhedron}" href="#SymmetryReduceBZ.Symmetry.inhull-Tuple{Any, Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Symmetry.inhull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inhull(point, chull; rtol, atol)</code></pre><p>Check if a point lies within a convex hull (including the boundaries).</p><p><strong>Arguments</strong></p><ul><li><code>point::AbstractVector{&lt;:Real}</code>: a point in Cartesian coordinates.</li><li><code>chull::Chull</code>: a convex hull in 2D or 3D.</li><li><code>rtol::Real=sqrt(eps(float(maximum(flatten(chull.points)))))</code>: a relative   tolerance for floating point comparisons. Needed when a point is on the   boundary of the convex hull.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>inside::Bool</code>: if true, the point lies within the convex hull.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import QHull: chull
import SymmetryReduceBZ.Symmetry: inhull
pts = [0.5 0.25; 0.5 -0.25; -0.5 -0.25; -0.5 0.25]
pt = [0,0]
convexhull = chull(pts)
inhull(pt,convexhull)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L246-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.make_primitive-Tuple{AbstractMatrix{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:Real, AbstractVector{var&quot;#s107&quot;} where var&quot;#s107&quot;&lt;:Integer, AbstractMatrix{var&quot;#s106&quot;} where var&quot;#s106&quot;&lt;:Real, String}" href="#SymmetryReduceBZ.Symmetry.make_primitive-Tuple{AbstractMatrix{var&quot;#s108&quot;} where var&quot;#s108&quot;&lt;:Real, AbstractVector{var&quot;#s107&quot;} where var&quot;#s107&quot;&lt;:Integer, AbstractMatrix{var&quot;#s106&quot;} where var&quot;#s106&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.make_primitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_primitive(real_latvecs,atom_types,atom_pos,coordinates;rtol,atol)</code></pre><p>Make a given unit cell primitive.</p><p>This is a Julia translation of the function by the same in     https://github.com/msg-byu/symlib.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractMatrix{&lt;:Real}</code>: the basis of the lattice as columns   of a matrix.</li><li><code>atom_types::AbstractVector{&lt;:Int}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractMatrix{&lt;:Real}</code>: the positions of atoms in the crystal   structure as columns of a matrix.</li><li><code>coordinates::String</code>: indicates the positions of the atoms are in &quot;lattice&quot;   or &quot;Cartesian&quot; coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>prim_latvecs::AbstractMatrix{&lt;:Real}</code>: the primitive lattice vectors as   columns of a matrix.</li><li><code>prim_types::AbstractVector{&lt;:Int}</code>: a list of atom types as integers in the   primitive unit cell.</li><li><code>prim_pos::AbstractMatrix{&lt;:Real}</code>: the positions of the atoms in in the   crystal structure as columns of a matrix in Cartesian coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import SymmetryReduceBZ.Lattices: genlat_CUB
import SymmetryReduceBZ.Symmetry: make_primitive
a = 1.0
real_latvecs = genlat_CUB(a)
atom_types = [0,0]
atom_pos = Array([0 0 0; 0.5 0.5 0.5]&#39;)
ibzformat = &quot;convex hull&quot;
coordinates = &quot;Cartesian&quot;
convention = &quot;ordinary&quot;
make_primitive(real_latvecs, atom_types, atom_pos, coordinates)
# output
([1.0 0.0 0.5; 0.0 1.0 0.5; 0.0 0.0 0.5], [0], [0.0; 0.0; 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L706-L749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_bz-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, AbstractMatrix{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, String}" href="#SymmetryReduceBZ.Symmetry.mapto_bz-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, AbstractMatrix{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_bz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapto_bz(kpoints,recip_latvecs,inv_rlatvecs,coordinates;rtol,atol)</code></pre><p>Map points as columns of a matrix to the Brillouin zone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_bz-Tuple{AbstractVector{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, AbstractMatrix{var&quot;#s56&quot;} where var&quot;#s56&quot;&lt;:Real, String}" href="#SymmetryReduceBZ.Symmetry.mapto_bz-Tuple{AbstractVector{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, AbstractMatrix{var&quot;#s56&quot;} where var&quot;#s56&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_bz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapto_bz(kpoint,recip_latvecs,inv_latvecs,coordinates;rtol,atol)</code></pre><p>Map a k-point to a translationally equivalent point within the Brillouin zone.</p><p><strong>Arguments</strong></p><ul><li><code>kpoint::AbstractVector{&lt;:Real}</code>: a single <em>k</em>-point in lattice or Cartesian   coordinates.</li><li><code>recip_latvecs::AbstractMatrix{&lt;:Real}</code>: the reciprocal lattice vectors as   columns of a matrix.</li><li><code>inv_latvecs::AbstractMatrix{&lt;:Real}</code>: the inverse matrix of the reciprocal   lattice vectors.</li><li><code>coordinates::String</code>: the coordinates of the given point, either &quot;lattice&quot;   or &quot;Cartesian&quot;. The point returned will be in the same coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(recip_latvecs))))</code>: a relative tolerance   for floating point comparisons. Finite precision errors creep in when <code>pt</code>   is transformed to lattice coordinates because the transformation requires   calculating a matrix inverse. The components of the <em>k</em>-point in lattice   coordinates are checked to ensure that values close to 1 are equal to 1.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>bz_point::AbstractVector{&lt;:Real}</code>: the symmetrically equivalent <em>k</em>-point   within the Brillouin zone in either lattice or Cartesian coordinates,   depending on the coordinates specified.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import SymmetryReduceBZ.Symmetry: mapto_bz
import LinearAlgebra: inv
recip_latvecs = [1 0 0; 0 1 0; 0 0 1]
inv_latvecs = inv(recip_latvecs)
kpoint = [2, 3, 2]
coordinates = &quot;Cartesian&quot;
mapto_bz(kpoint, recip_latvecs, inv_latvecs, coordinates)
# output
3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L154-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_ibz" href="#SymmetryReduceBZ.Symmetry.mapto_ibz"><code>SymmetryReduceBZ.Symmetry.mapto_ibz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapto_ibz(kpoints,recip_latvecs,inv_rlatvecs,ibz,pointgroup,coordinates;
    rtol,atol)</code></pre><p>Map points as columns of a matrix to the IBZ and then remove duplicate points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L359-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_ibz-Tuple{AbstractVector{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:Real, AbstractMatrix{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractMatrix{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real, Any, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(AbstractMatrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), String}" href="#SymmetryReduceBZ.Symmetry.mapto_ibz-Tuple{AbstractVector{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:Real, AbstractMatrix{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractMatrix{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real, Any, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(AbstractMatrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real), String}"><code>SymmetryReduceBZ.Symmetry.mapto_ibz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapto_ibz(kpoint,recip_latvecs,inv_rlatvecs,ibz,pointgroup,coordinates;rtol,
    atol)</code></pre><p>Map a point to a symmetrically equivalent point within the IBZ.</p><p><strong>Arguments</strong></p><ul><li><code>kpoint::AbstractVector{&lt;:Real}</code>: a <em>k</em>-point in 2D or 3D in Cartesian   coordinates.</li><li><code>recip_latvecs::AbstractMatrix{&lt;:Real}</code>: the reciprocal lattice vectors as   columns of a a matrix.</li><li><code>inv_rlatvecs::AbstractMatrix{&lt;:Real}</code>: the inverse of the square matrix   <code>recip_latvecs</code>.</li><li><code>ibz::Chull</code>: the irreducible Brillouin zone as as a convex hull   objects from <code>QHull</code>.</li><li><code>pointgroup::AbstractVector{&lt;:AbstractMatrix{&lt;:Real}}</code>: a list of point symmetry operators   in matrix form that operate on points from the left.</li><li><code>coordinates::String</code>: the coordinates the <em>k</em>-point is in. Options are   &quot;lattice&quot; and &quot;Cartesian&quot;. The <em>k</em>-point within the IBZ is returned in   the same coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(recip_latvecs))))</code>: a relative tolerance   for floating point comparisons. The <em>k</em>-point is first mapped the unit cell   and <code>rtol</code> is used when comparing components of the <em>k</em>-point to 1. It is   also used for comparing floats to zero when checking if the point lies   within <code>ibz</code>.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons. This   is used everywhere <code>rtol</code> is used.</li></ul><p><strong>Returns</strong></p><ul><li><code>rot_point::AbstractVector{&lt;:Real}</code>: a symmetrically equivalent <em>k</em>-point to   <code>kpoint</code> within the irreducible Brillouin zone in the same coordinates as   <code>coordinates</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import SymmetryReduceBZ.Lattices: get_recip_latvecs
import SymmetryReduceBZ.Symmetry: calc_spacegroup, mapto_ibz
import LinearAlgebra: inv
import QHull: chull
real_latvecs = [1 0; 0 2]
atom_types=[0]
atom_pos=Array([0 0]&#39;)
coordinates=&quot;Cartesian&quot;
convention=&quot;ordinary&quot;
recip_latvecs = get_recip_latvecs(real_latvecs,convention)
inv_rlatvecs = inv(recip_latvecs)
(ftrans,pg) = calc_spacegroup(real_latvecs,atom_types,atom_pos,coordinates)
ibz = chull([0.0 0.25; 0.0 0.0; 0.5 0.0; 0.5 0.25])
kpoint = [2,3]
ibz_point = mapto_ibz(kpoint,recip_latvecs,inv_rlatvecs,ibz,pg,coordinates)
# output
2-element Vector{Float64}:
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L279-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_unitcell-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, AbstractMatrix{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, String}" href="#SymmetryReduceBZ.Symmetry.mapto_unitcell-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, AbstractMatrix{var&quot;#s58&quot;} where var&quot;#s58&quot;&lt;:Real, AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_unitcell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapto_unitcell(points,latvecs,inv_latvecs,coordinates;rtol,atol)</code></pre><p>Map points as columns of a matrix to the unitcell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_unitcell-Tuple{AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, AbstractMatrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, String}" href="#SymmetryReduceBZ.Symmetry.mapto_unitcell-Tuple{AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, AbstractMatrix{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real, AbstractMatrix{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:Real, String}"><code>SymmetryReduceBZ.Symmetry.mapto_unitcell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapto_unitcell(pt,latvecs,inv_latvecs,coordinates;rtol,atol)</code></pre><p>Map a point to the first unit cell.</p><p><strong>Arguments</strong></p><ul><li><code>pt::AbstractVector{&lt;:Real}</code>: a point in lattice or Cartesian coordinates.</li><li><code>latvecs::AbstractMatrix{&lt;:Real}</code>: the basis vectors of the lattice as   columns of a matrix.</li><li><code>inv_latvecs::AbstractMatrix{&lt;:Real}</code>: the inverse of the matrix of that   contains the lattice vectors.</li><li><code>coordinates::String</code>: indicates whether <code>pt</code> is in &quot;Cartesian&quot; or   &quot;lattice&quot; coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(inv_latvecs))))</code>: a relative tolerance for   floating point comparisons. Finite precision errors creep up when <code>pt</code> is   transformed to lattice coordinates because the transformation requires   calculating a matrix inverse. The components of the point in lattice   coordinates are checked to ensure that values close to 1 are equal to 1.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector{&lt;:Real}</code>: a translationally equivalent point to <code>pt</code> in the   first unit cell in the same coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
real_latvecs = [0 1 2; 0 -1 1; 1 0 0]
inv_latvecs=inv(real_latvecs)
pt=[1,2,3.2]
coordinates = &quot;Cartesian&quot;
SymmetryReduceBZ.Symmetry.mapto_unitcell(pt,real_latvecs,inv_latvecs,
    coordinates)
# output
3-element Vector{Float64}:
 0.0
 0.0
 0.20000000000000018</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L85-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.pointgroup_size" href="#SymmetryReduceBZ.Symmetry.pointgroup_size"><code>SymmetryReduceBZ.Symmetry.pointgroup_size</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Give the size of the point group of a Bravais lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Symmetry.jl#L703">source</a></section></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.affine_trans-Tuple{AbstractMatrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.affine_trans-Tuple{AbstractMatrix{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.affine_trans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">affine_trans(pts)</code></pre><p>Calculate the affine transformation that maps the points to the xy-plane.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractMatrix{&lt;:Real}</code>: Cartesian points as the columns of a matrix.   The points must all lie on a plane in 3D.</li></ul><p><strong>Returns</strong></p><ul><li><code>M::AbstractMatrix{&lt;:Real}</code>: the affine transformation matrix that operates   on points in homogeneous coordinates from the left.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
pts = [0.5 0.5 0.5; 0.5 -0.5 0.5; -0.5 0.5 0.5; -0.5 -0.5 0.5]&#39;
SymmetryReduceBZ.Utilities.affine_trans(pts)
# output
4×4 Matrix{Float64}:
  0.0  -1.0   0.0  0.5
 -1.0   0.0   0.0  0.5
  0.0   0.0  -1.0  0.5
  0.0   0.0   0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L70-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.contains-Tuple{AbstractArray, AbstractArray}" href="#SymmetryReduceBZ.Utilities.contains-Tuple{AbstractArray, AbstractArray}"><code>SymmetryReduceBZ.Utilities.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(array,arrays;rtol,atol)</code></pre><p>Check if an array of arrays contains an array.</p><p><strong>Arguments</strong></p><ul><li><code>array::AbstractArray</code>: an array of reals of arbitrary dimension.</li><li><code>arrays::AbstractArray</code>: a nested array of arrays of arbitrary dimension.</li><li><code>rtol::Real=sqrt(eps(float(maximum(pts))))</code>: a relative tolerance for floating   point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: a boolean that indicates the presence of absence of <code>array</code> in   <code>arrays</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: contains
arrays = [[1 2; 2 3], [2 3; 4 5]]
array = [1 2; 2 3]
contains(array, arrays)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L143-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.contains-Tuple{AbstractVector{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real, AbstractMatrix{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.contains-Tuple{AbstractVector{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:Real, AbstractMatrix{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(pt,pts;rtol,atol)</code></pre><p>Check if a point is contained in a matrix of points as columns.</p><p><strong>Arguments</strong></p><ul><li><code>pt::AbstractVector{&lt;:Real}</code>: a point whose coordinates are the components of   a vector.</li><li><code>pts::AbstractMatrix{&lt;:Real}</code>: coordinates of points as columns of a matrix.</li><li><code>rtol::Real=sqrt(eps(float(maximum(pts))))</code>: a relative tolerance for floating   point comparisons</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: a boolean that indicates the presence or absence of <code>pt</code> in <code>pts</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: contains
pts = Array([1 2; 2 3; 3 4; 4 5]&#39;)
pt = [1,2]
contains(pt,pts)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L112-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.edgelengths-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, Real}" href="#SymmetryReduceBZ.Utilities.edgelengths-Tuple{AbstractMatrix{var&quot;#s59&quot;} where var&quot;#s59&quot;&lt;:Real, Real}"><code>SymmetryReduceBZ.Utilities.edgelengths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgelengths(basis,radius;rtol,atol)</code></pre><p>Calculate the edge lengths of a parallelepiped circumscribed by a sphere.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: a 2x2 or 3x3 matrix whose columns give the   parallelogram or parallelepiped directions, respectively.</li><li><code>radius::Real</code>: the radius of the sphere.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerace for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point   comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>[la,lb,lc]::AbstractVector{&lt;:Real}</code>: a list of parallelepiped lengths.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis=Array([1. 0. 0.; 0. 1. 0.; 0. 0. 1.])
radius=3.0
SymmetryReduceBZ.Utilities.edgelengths(basis,radius)
# output
3-element Vector{Float64}:
 3.0
 3.0
 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L175-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Polyhedra.Polyhedron}" href="#SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.get_uniquefacets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_uniquefacets(ch)</code></pre><p>Calculate the unique facets of a convex hull.</p><div class="admonition is-info"><header class="admonition-header">QHull.jl package extension</header><div class="admonition-body"><p>This function is compatible with <a href="https://github.com/JuliaPolyhedra/QHull.jl">QHull.jl</a> convex hulls through a package extension. After installing Python, SciPy, and QHull.jl, do <code>using QHull</code> to load it.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>ch::Polyhedron</code>: a polyhedron from Polyhedra.jl or convex hull in 3D from QHull.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>unique_facets::Vector{&lt;:Vector}</code>: a nested list of the vertices of points that lie on each face.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: get_uniquefacets
using SymmetryReduceBZ.Symmetry: calc_bz
real_latvecs = [1 0 0; 0 1 0; 0 0 1]
atom_types = [0]
atom_pos = Array([0 0 0]&#39;)
coordinates = &quot;Cartesian&quot;
makeprim = false
convention = &quot;ordinary&quot;
bz = calc_bz(real_latvecs,atom_types,atom_pos,coordinates,makeprim,convention)
get_uniquefacets(bz)
# output
6-element Vector{Vector{Vector{Float64}}}:
 [[-0.5, 0.5, -0.5], [-0.5, 0.5, 0.5], [-0.5, -0.5, 0.5], [-0.5, -0.5, -0.5]]
 [[0.5, -0.5, 0.5], [0.5, -0.5, -0.5], [-0.5, -0.5, -0.5], [-0.5, -0.5, 0.5]]
 [[0.5, -0.5, -0.5], [0.5, 0.5, -0.5], [-0.5, 0.5, -0.5], [-0.5, -0.5, -0.5]]
 [[0.5, -0.5, 0.5], [0.5, 0.5, 0.5], [-0.5, 0.5, 0.5], [-0.5, -0.5, 0.5]]
 [[0.5, 0.5, -0.5], [0.5, 0.5, 0.5], [-0.5, 0.5, 0.5], [-0.5, 0.5, -0.5]]
 [[0.5, -0.5, 0.5], [0.5, -0.5, -0.5], [0.5, 0.5, -0.5], [0.5, 0.5, 0.5]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L293-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.get_uniquefacetsindices-Tuple{Polyhedra.Polyhedron}" href="#SymmetryReduceBZ.Utilities.get_uniquefacetsindices-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.get_uniquefacetsindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_uniquefacetsindices(ch)</code></pre><p>Calculate the indices of unique facets of a convex hull.</p><div class="admonition is-info"><header class="admonition-header">QHull.jl package extension</header><div class="admonition-body"><p>This function is compatible with <a href="https://github.com/JuliaPolyhedra/QHull.jl">QHull.jl</a> convex hulls through a package extension. After installing Python, SciPy, and QHull.jl, do <code>using QHull</code> to load it.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>ch::Polyhedron</code>: a polyhedron from Polyhedra.jl or convex hull in 3D from QHull.jl.</li></ul><p><strong>Returns</strong></p><ul><li><code>unique_facets::Vector{&lt;:Vector}</code>: a nested list of the indices of points that lie on each face. See <a href="#SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Polyhedra.Polyhedron}"><code>get_uniquefacets</code></a> if you want the facets&#39; points.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using QHull: chull
using SymmetryReduceBZ.Utilities: get_uniquefacetsindices, vertices
using SymmetryReduceBZ.Symmetry: calc_bz
real_latvecs = [1 0 0; 0 1 0; 0 0 1]
atom_types = [0]
atom_pos = Array([0 0 0]&#39;)
coordinates = &quot;Cartesian&quot;
makeprim = false
convention = &quot;ordinary&quot;
bz = calc_bz(real_latvecs,atom_types,atom_pos,coordinates,makeprim,convention)
ch = chull(permutedims(reduce(hcat, vertices(bz))))
get_uniquefacetsindices(ch)
# output
6-element Vector{Vector{Int32}}:
 [1, 2, 3, 4]
 [7, 2, 3, 5]
 [6, 4, 3, 5]
 [7, 2, 1, 8]
 [6, 4, 1, 8]
 [8, 7, 5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L242-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.mapto_xyplane-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.mapto_xyplane-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.mapto_xyplane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function mapto_xyplane(pts)</code></pre><p>Map Cartesian points embedded in 3D on a plane to the xy-plane embedded in 2D.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractMatrix{&lt;:Real}</code>: Cartesian points embedded in 3D as columns of a   matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{&lt;:Real}</code>: Cartesian points in 2D as columns of a matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
pts = [0.5 -0.5 0.5; 0.5 -0.5 -0.5; 0.5 0.5 -0.5; 0.5 0.5 0.5]&#39;
SymmetryReduceBZ.Utilities.mapto_xyplane(pts)
# output
2×4 Matrix{Float64}:
 0.0  1.0  1.0  0.0
 0.0  0.0  1.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L337-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.points_in_ball-Tuple{AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, Real, AbstractVector{var&quot;#s56&quot;} where var&quot;#s56&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.points_in_ball-Tuple{AbstractMatrix{var&quot;#s57&quot;} where var&quot;#s57&quot;&lt;:Real, Real, AbstractVector{var&quot;#s56&quot;} where var&quot;#s56&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.points_in_ball</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">points_in_ball(points,radius,offset,rtol=sqrt(eps(float(radius))),atol=1e-9)</code></pre><p>Calculate the points within a ball (circle, sphere, ...).</p><p><strong>Arguments</strong></p><ul><li><code>points::AbstractMatrix{&lt;:Real}</code>: points in Cartesian coordinates as columns of a matrix.</li><li><code>radius::Real</code>: the radius of the ball.</li><li><code>offset::AbstractVector{&lt;:Real}</code>: the location of the center of the ball in Cartesian coordinates.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerance for floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>ball_points::AbstractVector{&lt;:Int}</code>: the indices of points in <code>points</code> within the ball.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: points_in_ball
points = [0.0 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.25 0.3 0.35 0.4 0.45 0.5 0.3 0.35 0.4 0.45 0.5 0.35 0.4 0.45 0.5 0.4 0.45 0.5 0.45 0.5 0.5; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.05 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.15 0.15 0.15 0.15 0.15 0.15 0.15 0.15 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.25 0.25 0.25 0.25 0.25 0.25 0.3 0.3 0.3 0.3 0.3 0.35 0.35 0.35 0.35 0.4 0.4 0.4 0.45 0.45 0.5]
radius = 0.1
offset = [0,0]
points_in_ball(points,radius,offset)
# output
4-element Vector{Int64}:
  1
  2
  3
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L649-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.remove_duplicates-Tuple{AbstractVector{T} where T}" href="#SymmetryReduceBZ.Utilities.remove_duplicates-Tuple{AbstractVector{T} where T}"><code>SymmetryReduceBZ.Utilities.remove_duplicates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_duplicates(points;rtol,atol)</code></pre><p>Remove duplicates from an array.</p><p><strong>Arguments</strong></p><ul><li><code>points::AbstractVector</code>: items in a vector, which can be floats or arrays.</li><li><code>rtol::Real=sqrt(eps(float(maximum(points))))</code>: relative tolerance.</li><li><code>atol::Real=1e-9</code>: absolute tolerance.</li></ul><p><strong>Returns</strong></p><ul><li><code>uniquepts::AbstractVector</code>: an vector with only unique elements.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: remove_duplicates
test = [1.,1.,2,2,]
remove_duplicates(test)
# output
2-element Vector{Float64}:
 1.0
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L609-L632">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sample_circle" href="#SymmetryReduceBZ.Utilities.sample_circle"><code>SymmetryReduceBZ.Utilities.sample_circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_circle(basis,radius,offset;rtol,atol)</code></pre><p>Sample uniformly within a circle centered about a point.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: a 2x2 matrix whose columns are the grid   generating vectors.</li><li><code>radius::Real</code>: the radius of the circle.</li><li><code>offset::AbstractVector{&lt;:Real}=[0.,0.]</code>: the xy-coordinates of the center of   the circle.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerace for floating point   comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>pts::AbstractMatrix{&lt;:Real}</code> a matrix whose columns are sample points in Cartesian   coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis=Array([1. 0.; 0. 1.]&#39;)
radius=1.0
offset=[0.,0.]
SymmetryReduceBZ.Utilities.sample_circle(basis,radius,offset)
# output
2×5 Matrix{Float64}:
  0.0  -1.0  0.0  1.0  0.0
 -1.0   0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L366-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sample_sphere" href="#SymmetryReduceBZ.Utilities.sample_sphere"><code>SymmetryReduceBZ.Utilities.sample_sphere</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_sphere(basis,radius,offset;rtol,atol)</code></pre><p>Sample uniformly within a sphere centered about a point.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractMatrix{&lt;:Real}</code>: a 3x3 matrix whose columns are the grid generating   vectors.</li><li><code>radius::Real</code>: the radius of the sphere.</li><li><code>offset::AbstractVector{&lt;:Real}=[0.,0.]</code>: the xy-coordinates of the center of the   circle.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerace for   floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point   comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>pts::AbstractMatrix{&lt;:Real}</code> a matrix whose columns are sample points in Cartesian   coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
basis=Array([1. 0. 0.; 0. 1. 0.; 0. 0. 1.])
radius=1.0
offset=[0.,0.,0.]
SymmetryReduceBZ.Utilities.sample_sphere(basis,radius,offset)
# output
3×7 Matrix{Float64}:
  0.0   0.0  -1.0  0.0  1.0  0.0  0.0
  0.0  -1.0   0.0  0.0  0.0  1.0  0.0
 -1.0   0.0   0.0  0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L421-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.shoelace-Tuple{AbstractMatrix{var&quot;#s63&quot;} where var&quot;#s63&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.shoelace-Tuple{AbstractMatrix{var&quot;#s63&quot;} where var&quot;#s63&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.shoelace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shoelace(vertices)</code></pre><p>Calculate the area of a polygon with the shoelace algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>vertices::AbstractMatrix{&lt;:Real}</code>: the xy-coordinates of the vertices   of the polygon as the columns of a matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>area::Real</code>: the area of the polygon.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: shoelace
pts = [0 0 1; -1 1 0]
shoelace(pts)
# output
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L478-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sortpts2D-Tuple{AbstractMatrix{var&quot;#s62&quot;} where var&quot;#s62&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.sortpts2D-Tuple{AbstractMatrix{var&quot;#s62&quot;} where var&quot;#s62&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.sortpts2D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sortpts2D(pts)</code></pre><p>Calculate the permutation vector that sorts 2D Cartesian points counterclockwise with     respect to the average of the points.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractMatrix{&lt;:Real}</code>: Cartesian points in 2D.</li></ul><p><strong>Returns</strong></p><ul><li><code>perm::AbstractVector{&lt;:Real}</code>: the permutation vector that orders the points   clockwise or counterclockwise.</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L511-L524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sortpts_perm-Tuple{AbstractMatrix{var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.sortpts_perm-Tuple{AbstractMatrix{var&quot;#s64&quot;} where var&quot;#s64&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.sortpts_perm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sortpts_perm(pts)</code></pre><p>Calculate the permutation vector that sorts Cartesian points embedded in 3D that     lie on a plane (counter)clockwise with respect to the average of all points.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractMatrix{&lt;:Real}</code>: Cartesian points embedded in 3D that all lie   on a plane. The points are columns of a matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>::AbstractVector{&lt;:Real}</code>: the permutation vector that orders the points   clockwise or counterclockwise.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: sortpts_perm
pts = [0.5 -0.5 0.5; 0.5 -0.5 -0.5; 0.5 0.5 -0.5; 0.5 0.5 0.5]&#39;
perm=sortpts_perm(pts)
pts[:,perm]
# output
3×4 Matrix{Float64}:
  0.5   0.5   0.5  0.5
 -0.5  -0.5   0.5  0.5
  0.5  -0.5  -0.5  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L535-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.unique_points-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.unique_points-Tuple{AbstractMatrix{var&quot;#s60&quot;} where var&quot;#s60&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.unique_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_points(points;rtol,atol)</code></pre><p>Remove duplicate points.</p><p><strong>Arguments</strong></p><ul><li><code>points::AbstractMatrix{&lt;:Real}</code>: the points are columns of a matrix.</li><li><code>rtol::Real=sqrt(eps(float(maximum(flatten(points)))))</code>: a relative tolerance   for floating point comparisons.</li><li><code>atol::Real=1e-9</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>uniquepts::AbstractMatrix{&lt;:Real}</code>: the unique points as columns of a matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ
points=Array([1 2; 2 3; 3 4; 1 2]&#39;)
SymmetryReduceBZ.Utilities.unique_points(points)
# output
2×3 Matrix{Int64}:
 1  2  3
 2  3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L567-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.vertices-Tuple{Polyhedra.Polyhedron}" href="#SymmetryReduceBZ.Utilities.vertices-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(hull)</code></pre><p><strong>Arguments</strong></p><ul><li><code>hull::Polyhedron</code>: a convex hull of a polytope</li></ul><p><strong>Returns</strong></p><ul><li><code>pts</code>: a iterator of points (vectors) at the vertices of the convex hull</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: vertices
using SymmetryReduceBZ.Symmetry: calc_bz
real_latvecs = [1 0 0; 0 1 0; 0 0 1]
atom_types = [0]
atom_pos = Array([0 0 0]&#39;)
coordinates = &quot;Cartesian&quot;
makeprim = false
convention = &quot;ordinary&quot;
bz = calc_bz(real_latvecs,atom_types,atom_pos,coordinates,makeprim,convention)
vertices(bz)
# output
8-element iterator of Vector{Float64}:
 [0.5, -0.5, 0.5]
 [0.5, -0.5, -0.5]
 [0.5, 0.5, -0.5]
 [0.5, 0.5, 0.5]
 [-0.5, 0.5, -0.5]
 [-0.5, 0.5, 0.5]
 [-0.5, -0.5, -0.5]
 [-0.5, -0.5, 0.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L35-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.volume-Tuple{Polyhedra.Polyhedron}" href="#SymmetryReduceBZ.Utilities.volume-Tuple{Polyhedra.Polyhedron}"><code>SymmetryReduceBZ.Utilities.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volume(hull)</code></pre><p><strong>Arguments</strong></p><ul><li><code>hull::Polyhedron</code></li></ul><p><strong>Returns</strong></p><ul><li><code>vol::Real</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymmetryReduceBZ.Utilities: volume
using SymmetryReduceBZ.Symmetry: calc_bz
real_latvecs = [1 0 0; 0 1 0; 0 0 1]
atom_types = [0]
atom_pos = Array([0 0 0]&#39;)
coordinates = &quot;Cartesian&quot;
makeprim = false
convention = &quot;ordinary&quot;
bz = calc_bz(real_latvecs,atom_types,atom_pos,coordinates,makeprim,convention)
volume(bz)
# output
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/23f5c317dd305a4b5213d045e24a4830c08a3b47/src/Utilities.jl#L8-L32">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Usage/">User guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 13 February 2024 17:59">Tuesday 13 February 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
