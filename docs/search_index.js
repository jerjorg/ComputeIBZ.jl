var documenterSearchIndex = {"docs":
[{"location":"Documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"Documentation/#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"Documentation/#Lattices","page":"Documentation","title":"Lattices","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Lattices]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#Plotting","page":"Documentation","title":"Plotting","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Plotting]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#Symmetry","page":"Documentation","title":"Symmetry","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Symmetry]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#Utilites","page":"Documentation","title":"Utilites","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Utilities]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#Functions","page":"Documentation","title":"Functions","text":"","category":"section"},{"location":"Documentation/#Lattices-2","page":"Documentation","title":"Lattices","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Lattices]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#IBZ.Lattices.check_reduced-Tuple{AbstractArray{var\"#s14\",2} where var\"#s14\"<:Real}","page":"Documentation","title":"IBZ.Lattices.check_reduced","text":"check_reduced(basis)\n\nVerify a lattice basis is Minkowski reduced\n\nArguments\n\nbasis::AbstractArray{<:Real,2}: the lattice basis given by the columns   of a 2x2 or 3x3 matrix.\n\nReturns\n\nBool: a boolean that indicates if the lattice basis is reduced.\n\nExamples\n\nusing IBZ\nbasis = [1 0; 0 1]\nIBZ.Lattices.check_reduced(basis)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_BCC-Tuple{Real}","page":"Documentation","title":"IBZ.Lattices.genlat_BCC","text":"genlat_BCC(a)\n\nGenerate a body-centered cubic lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nIBZ.Lattices.genlat_BCC(a)\n# output\n3×3 Array{Float64,2}:\n -0.5   0.5   0.5\n  0.5  -0.5   0.5\n  0.5   0.5  -0.5\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_BCT-Tuple{Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_BCT","text":"genlat_BCT(a,c)\n\nGenerate a body-centered tetragonal lattice.\n\nArguments\n\na::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nc=1.2;\nIBZ.Lattices.genlat_BCT(a,c)\n# output\n3×3 Array{Float64,2}:\n -0.5   0.5   0.5\n  0.5  -0.5   0.5\n  0.6   0.6  -0.6\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_CUB-Tuple{Real}","page":"Documentation","title":"IBZ.Lattices.genlat_CUB","text":"genlat_CUB(a)\n\nGenerate a simple cubic lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nIBZ.Lattices.genlat_CUB(a)\n# output\n3×3 Array{Int64,2}:\n 1  0  0\n 0  1  0\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_FCC-Tuple{Real}","page":"Documentation","title":"IBZ.Lattices.genlat_FCC","text":"genlat_FCC(a)\n\nGenerate a face-centered cubic lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nIBZ.Lattices.genlat_FCC(a)\n# output\n3×3 Array{Float64,2}:\n 0.0  0.5  0.5\n 0.5  0.0  0.5\n 0.5  0.5  0.0\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_HEX-Tuple{Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_HEX","text":"genlat_HEX(a,c)\n\nGenerate a hexagonal lattice.\n\nArguments\n\na::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nc=1.2;\nIBZ.Lattices.genlat_HEX(a,c)\n# output\n3×3 Array{Float64,2}:\n  0.5       0.5       0.0\n -0.866025  0.866025  0.0\n  0.0       0.0       1.2\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_HXG-Tuple{Real}","page":"Documentation","title":"IBZ.Lattices.genlat_HXG","text":"genlat_HXG(a)\n\nGenerate a 2D hexagonal lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nIBZ.Lattices.genlat_HXG(a)\n# output\n2×2 Array{Float64,2}:\n 1.0  -0.5\n 0.0   0.866025\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_MCL-NTuple{4,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_MCL","text":"genlat_MCL(a,b,c,α)\n\nGenerate a monoclinic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\nα::Real: a lattice angle in radians less than π/2\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2\nc=1.4\nα=π/6;\nIBZ.Lattices.genlat_MCL(a,b,c,α)\n# output\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.2  1.21244\n 0.0  0.0  0.7\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_MCLC-NTuple{4,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_MCLC","text":"genlat_MCLC(a,b,c,α)\n\nGenerate a base-centered monoclinic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\nα::Real: a lattice angle in radians less than π/2\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2\nc=1.4\nα=π/6;\nIBZ.Lattices.genlat_MCLC(a,b,c,α)\n# output\n3×3 Array{Float64,2}:\n 0.5  -0.5  0.0\n 0.6   0.6  1.21244\n 0.0   0.0  0.7\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_OBL-Tuple{Real,Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_OBL","text":"genlat_OBL(a,b,θ)\n\nGenerate a body-centered rectangular lattice.\n\nArguments\n\na::Real: the lattice constant\nb::Real: the lattice constant\nθ::Real: the lattice angle\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2\nθ=π/3\nIBZ.Lattices.genlat_OBL(a,b,θ)\n# output\n2×2 Array{Float64,2}:\n 1.0  0.6\n 0.0  1.03923\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_ORC-Tuple{Real,Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_ORC","text":"genlat_ORC(a,b,c)\n\nGenerate an orthorhombic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.4;\nc=1.2;\nIBZ.Lattices.genlat_ORC(a,b,c)\n# output\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.4  0.0\n 0.0  0.0  1.2\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_ORCC-Tuple{Real,Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_ORCC","text":"genlat_ORCC(a,b,c)\n\nGenerate a base-centered orthorhombic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2;\nc=1.4;\nIBZ.Lattices.genlat_ORCC(a,b,c)\n# output\n3×3 Array{Float64,2}:\n  0.5  0.5  0.0\n -0.6  0.6  0.0\n  0.0  0.0  1.4\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_ORCF-Tuple{Real,Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_ORCF","text":"genlat_ORCF(a,b,c)\n\nGenerate a face-centered orthorhombic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.4;\nc=1.2;\nIBZ.Lattices.genlat_ORCF(a,b,c)\n# output\n3×3 Array{Float64,2}:\n 0.0  0.5  0.5\n 0.7  0.0  0.7\n 0.6  0.6  0.0\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_ORCI-Tuple{Real,Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_ORCI","text":"genlat_ORCI(a,b,c)\n\nGenerate a body-centered orthorhombic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.4;\nc=1.2;\nIBZ.Lattices.genlat_ORCI(a,b,c)\n# output\n3×3 Array{Float64,2}:\n -0.5   0.5   0.5\n  0.7  -0.7   0.7\n  0.6   0.6  -0.6\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_REC-Tuple{Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_REC","text":"genlat_REC(a,b)\n\nGenerate a rectangular lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2\nIBZ.Lattices.genlat_REC(a,b)\n# output\n2×2 Array{Float64,2}:\n 1.0  0.0\n 0.0  1.2\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_RECI-Tuple{Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_RECI","text":"genlat_RECI(a,b)\n\nGenerate a body-centered rectangular lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2\nIBZ.Lattices.genlat_RECI(a,b)\n# output\n2×2 Array{Float64,2}:\n  0.5  0.5\n -0.6  0.6\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_RHL-Tuple{Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_RHL","text":"genlat_RHL(a,α)\n\nGenerate a rhombohedral lattice.\n\nArguments\n\na::Real: a lattice constant\nα::Real: a lattice angle in radians\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nα=π/6;\nIBZ.Lattices.genlat_RHL(a,α)\n# output\n3×3 Array{Float64,2}:\n  0.965926  0.965926  0.896575\n -0.258819  0.258819  0.0\n  0.0       0.0       0.442891\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_SQR-Tuple{Real}","page":"Documentation","title":"IBZ.Lattices.genlat_SQR","text":"genlat_SQR(a)\n\nGenerate a square lattice.\n\nArguments\n\na::Real: the lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nIBZ.Lattices.genlat_SQR(a)\n# output\n2×2 Array{Int64,2}:\n 1  0\n 0  1\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_TET-Tuple{Real,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_TET","text":"genlat_TET(a,c)\n\nGenerate a simple tetragonal lattice.\n\nArguments\n\na::Real: a lattice constant\nc::Real: a lattice constant\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nc=1.2;\nIBZ.Lattices.genlat_TET(a,c)\n# output\n3×3 Array{Float64,2}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.2\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.genlat_TRI-NTuple{6,Real}","page":"Documentation","title":"IBZ.Lattices.genlat_TRI","text":"genlat_TRI(a,b,c,α,β,γ)\n\nGenerate a triclinic lattice.\n\nArguments\n\na::Real: a lattice constant\nb::Real: a lattice constant\nc::Real: a lattice constant\nα::Real: a lattice angle in radians\nβ::Real: a lattice angle in radians\nγ::Real: a lattice angle in radians\n\nReturns\n\nAbstractArray{<:Real,2}: the basis of the lattice as   columns of an array.\n\nExamples\n\nusing IBZ\na=1\nb=1.2\nc=1.4\nα=π/6;\nβ=π/3;\nγ=π/4;\nIBZ.Lattices.genlat_TRI(a,b,c,α,β,γ)\n# output\n3×3 Array{Float64,2}:\n 1.0  0.848528  0.7\n 0.0  0.848528  1.01464\n 0.0  0.0       0.663702\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.get_latparams-Tuple{Any}","page":"Documentation","title":"IBZ.Lattices.get_latparams","text":"get_latparams(latvecs)\n\nCalculate the lattice constants and angles of a lattice basis.\n\nArguments\n\nlatvecs::AbstractArray{<:Real,2}: the lattice basis as columns of an array.\n\nReturns\n\nA list where the first element is a list lattice constants (a,b,c) and second   lattice angles in radians (α,β,γ).\n\nExamples\n\nusing IBZ\nlatvecs = [1 0; 0 1]\nIBZ.Lattices.get_latparams(latvecs)\n# output\n2-element Array{Array{Float64,1},1}:\n [1.0, 1.0]\n [1.5707963267948966, 1.5707963267948966]\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.get_recip_latvecs","page":"Documentation","title":"IBZ.Lattices.get_recip_latvecs","text":"get_recip_latvecs(real_latvecs, convention)\n\nCalculate the reciprocal lattice vectors.\n\nArguments\n\nreal_latvecs::AbstractArray{<:Real,2}: the real-space lattice vectors or   primitive translation vectors as columns of a 2x2 or 3x3 array.\nconvention::String=\"ordinary\": the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.\n\nReturns\n\nrecip_latvecs::Array{<:Real,2} the reciprocal lattice vectors (reciprocal   primitive translation vectors) as columns of a 2x2 or 3x3 array.\n\nExamples\n\nusing IBZ\nreal_latvecs=[1 0 0; 0 1 0; 0 0 1]\nconvention=\"angular\"\nIBZ.Lattices.get_recip_latvecs(real_latvecs,convention)\n# output\n3×3 Array{Float64,2}:\n 6.28319  0.0      0.0\n 0.0      6.28319  0.0\n 0.0      0.0      6.28319\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Lattices.minkowski_reduce-Tuple{AbstractArray{var\"#s15\",2} where var\"#s15\"<:Real}","page":"Documentation","title":"IBZ.Lattices.minkowski_reduce","text":"    minkowski_reduce(basis)\n\nMinkowski reduce a lattice basis. Follows the logic of Fig. 4 in \"Low-Dimensional Lattice Basis Reduction Revisited\" by Nguyen, 2009.\n\nArguments\n\nbasis::AbstractArray{<:Real,2}: the lattice basis given by the columns   of a 2x2 or 3x3 array.\n\nReturns\n\n`rbasis:: the Minkowski reduced lattice basis as columns of an array.\n\nExamples\n\nusing IBZ\nbasis = [1 2 0; 0 1 0; 0 0 1]\nIBZ.Lattices.minkowski_reduce(basis)\n# output\n3×3 Array{Int64,2}:\n 0  1  0\n 0  0  1\n 1  0  0\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Lattices.reduce_basis!-Tuple{AbstractArray{var\"#s17\",2} where var\"#s17\"<:Real,Int64}","page":"Documentation","title":"IBZ.Lattices.reduce_basis!","text":"reduce_basis!(basis,k)\n\nReduces the kth lattice vector. This is accomplished by locating the lattice point closest to the projection of the kth lattice vector onto the line or plane given by the other lattice vector(s), subtracting the closest lattice point from the kth lattice vector, and reordering the lattice vectors by increasing Euclidean norms.\n\nArguments\n\nbasis::AbstractArray{<:Real,2}: the lattice basis as columns of an array.\nk::Int: Keeps track of which lattice vector needs to be reduced.\n\nReturns\n\nbasis::AbstractArray{<:Real,2}: the partially reduced lattice basis as   columns of an array.\nk::Int: The index of the lattice vector that needs to be reduced next.\n\nExamples\n\nusing IBZ\nbasis = Array([1 2 0; 0 1 0; 3 2 1]')\nk=2\nIBZ.Lattices.reduce_basis!(basis,k)\nbasis\n# output\n3×3 Array{Int64,2}:\n 0  1  3\n 1  2  2\n 0  0  1\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#Plotting-2","page":"Documentation","title":"Plotting","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Plotting]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#IBZ.Plotting.plot_2Dconvexhull-Tuple{QHull.Chull{var\"#s154\"} where var\"#s154\"<:Real,PyCall.PyObject,String}","page":"Documentation","title":"IBZ.Plotting.plot_2Dconvexhull","text":"plot_2Dconvexhull(convexhull, ax, color)\n\nPlot a 2D convex hull\n\nArguments\n\nconvexhull::Chull{<:Real}: a convex hull object.\nax::PyObject: an axes object from matplotlib.\ncolor::String: the face color of the convex hull.\n\nReturns\n\nax::PyObject: updated ax that includes a plot of the convex hull.\n\nExamples\n\nusing IBZ\nreal_latvecs = [1 0; 0 1]\nconvention = \"ordinary\"\nbzformat = \"convex hull\"\nbz = calc_bz(real_latvecs,convention,bzformat)\n\nfig,ax=subplots(figsize=figaspect(1)*1.5)\nax = IBZ.Plotting.plot_2Dconvexhull(bz,ax,\"deepskyblue\");\ncolor=\"deepskyblue\"\nIBZ.Plotting.plot_2Dconvexhull(bz,ax,color)\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Plotting.plot_3Dconvexhull","page":"Documentation","title":"IBZ.Plotting.plot_3Dconvexhull","text":"plot_3Dconvexhull(convexhull, ax, color)\n\nPlot a 3D convex hull\n\nArguments\n\nconvexhull::Chull{<:Real}: a convex hull object.\nax::PyObject: an axes object from matplotlib.\ncolor::String: the face color of the convex hull.\nplotrange=false: the range over which to plot the convex hull.\n\nReturns\n\nax::PyObject: updated ax that includes a plot of the convex hull.\n\nExamples\n\nusing IBZ\nreal_latvecs = [1 0 0; 0 1 0; 0 0 1]\nconvention = \"ordinary\"\nbzformat = \"convex hull\"\nbz = calc_bz(real_latvecs,convention,bzformat)\nfig = figure(figsize=figaspect(1)*1.5)\nax = fig.add_subplot(111, projection=\"3d\")\nax = IBZ.Plotting.plot_3Dconvexhull(bz,ax,\"deepskyblue\")\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Plotting.plot_convexhulls","page":"Documentation","title":"IBZ.Plotting.plot_convexhulls","text":"plot_convexhulls(real_latvecs,atom_types,atom_pos,coords,convention,rtol,\n  atol)\n\nPlot the Brillouin and Irreducible Brillouin zone in 2D or 3D.\n\nArguments\n\nreal_latvecs::AbstractArray{<:Real,2}: the basis of a real-space lattice as   columns of an array.\natom_types:AbstractArray{<:Int,1}: a list of atom types as integers.\natom_pos::AbstractArray{<:Real,2}: the positions of atoms in the crystal   structure as columns of an array.\ncoords::String: indicates the positions of the atoms are in \"lattice\" or   \"Cartesian\" coordinates.\nconvention::String=\"ordinary\": the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.\nrtol::Real=sqrt(eps(float(maximum(real_latvecs)))) a relative tolerance for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\n(fig,ax): the figure and axes Python objects.\n\nExamples\n\nusing IBZ\nreal_latvecs = [1 0; .5 1]\natom_types=[0]\ncoords = \"Cartesian\"\natom_pos = Array([0 0]')\nconvention = \"ordinary\"\n(fig,ax)=plot_convexhulls(real_latvecs,atom_types,atom_pos,coords,convention)\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#Symmetry-2","page":"Documentation","title":"Symmetry","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Symmetry]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#IBZ.Symmetry.calc_bz-Tuple{AbstractArray{var\"#s127\",2} where var\"#s127\"<:Real,String,String}","page":"Documentation","title":"IBZ.Symmetry.calc_bz","text":"calc_bz(real_latvecs, convention, bzformat)\n\nCalculate the Brillouin zone for the given real-space lattice basis.\n\nArguments\n\nreal_latvecs::AbstractArray{<:Real,2}: the real-space lattice vectors or   primitive translation vectors as columns of a 2x2 or 3x3 array.\nconvention::String=\"ordinary\": the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.\nbzformat::String: the format of the Brillouin zone. Options include   \"convex-hull\" and \"half-space\".\n\nReturns\n\nbz: the vertices or half-space representation of the Brillouin zone   depending on the value of vertsOrHrep.\n\nExamples\n\nusing IBZ\nreal_latvecs=[1 0; 0 1]\nconvention=\"ordinary\"\nbzformat = \"convex hull\"\nIBZ.Symmetry.calc_bz(real_latvecs,convention,bzformat)\n# output\nConvex Hull of 4 points in 2 dimensions\nHull segment vertex indices:\n[3, 2, 1, 4]\nPoints on convex hull in original order:\n\n[0.5 0.5; 0.5 -0.5; -0.5 -0.5; -0.5 0.5]\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Symmetry.calc_ibz","page":"Documentation","title":"IBZ.Symmetry.calc_ibz","text":"calc_ibz(real_latvecs,atom_types,atom_pos,coords,ibzformat,convention,rtol,\n    atol)\n\nCalculate the irreducible Brillouin zone of a crystal structure in 2D or 3D.\n\nArguments\n\nreal_latvecs::AbstractArray{<:Real,2}: the basis of a real-space lattice as   columns of an array.\natom_types:AbstractArray{<:Int,1}: a list of atom types as integers.\natom_pos::AbstractArray{<:Real,2}: the positions of atoms in the crystal   structure as columns of an array.\ncoords::String: indicates the positions of the atoms are in \"lattice\" or   \"Cartesian\" coordinates.\nibzformat::String: the format of the irreducible Brillouin zone. Options   include \"convex-hull\" and \"half-space\".\nconvention::String=\"ordinary\": the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.\nrtol::Real=sqrt(eps(float(maximum(real_latvecs)))) a relative tolerance for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\nibz: the irreducible Brillouin zone as a convex hull or intersection of   half-spaces.\n\nExamples\n\nusing IBZ\nreal_latvecs = [1 0; 0 1]\nconvention=\"ordinary\"\natom_types=[0]\natom_pos = Array([0 0]')\ncoords = \"Cartesian\"\nibzformat = \"convex hull\"\nIBZ.Symmetry.calc_ibz(real_latvecs,atom_types,atom_pos,coords,ibzformat,\n    convention)\n# output\nConvex Hull of 3 points in 2 dimensions\nHull segment vertex indices:\n[1, 2, 3]\nPoints on convex hull in original order:\n\n[0.0 0.0; 0.5 0.0; 0.5 0.5]\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Symmetry.calc_pointgroup","page":"Documentation","title":"IBZ.Symmetry.calc_pointgroup","text":"calc_pointgroup(latvecs,rtol,atol)\n\nCalculate the point group of lattice in 2D or 3D.\n\nArguments\n\nlatvecs::AbstractArray{<:Real,2}: the basis of the lattice as columns of an   array.\nrtol::Real=sqrt(eps(float(maximum(real_latvecs)))): a relative tolerance for   floating point comparisons. It is used to compare lengths of vectors and the   volumes of primitive cells.\natol::Real=0.0: an absolute tolerance for floating point comparisons. It is   used to compare lengths of vectors and the volumes of primitive cells.\n\nReturns\n\npointgroup::Array{Array{Float64,2},1}: the point group of the lattice. The   operators operate on points in Cartesian coordinates.\n\nExamples\n\nusing IBZ\nbasis = [1 0; 0 1]\nIBZ.Symmetry.calc_pointgroup(basis)\n# output\n8-element Array{Array{Float64,2},1}:\n [0.0 -1.0; -1.0 0.0]\n [0.0 -1.0; 1.0 0.0]\n [-1.0 0.0; 0.0 -1.0]\n [1.0 0.0; 0.0 -1.0]\n [-1.0 0.0; 0.0 1.0]\n [1.0 0.0; 0.0 1.0]\n [0.0 1.0; -1.0 0.0]\n [0.0 1.0; 1.0 0.0]\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Symmetry.calc_spacegroup","page":"Documentation","title":"IBZ.Symmetry.calc_spacegroup","text":"calc_spacegroup(real_latvecs,atom_types,atom_pos,coords,rtol,atol)\n\nCalculate the space group of a crystal structure.\n\nArguments\n\nreal_latvecs::AbstractArray{<:Real,2}: the basis of the lattice as columns   of an array.\natom_types::AbstractArray{<:Int,1}: a list of atom types as integers.\natom_pos::AbstractArray{<:Real,2}: the positions of atoms in the crystal   structure as columns of an array.\ncoords::String: indicates the positions of the atoms are in \"lattice\" or   \"Cartesian\" coordinates.\nrtol::Real=sqrt(eps(float(maximum(real_latvecs)))) a relative tolerance for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\nspacegroup: the space group of the crystal structure. The first element of   spacegroup is a list of fractional translations, and the second element is   a list of point operators. The translations are in Cartesian coordinates,   and the operators operate on points in Cartesian coordinates.\n\nExamples\n\nusing IBZ\nreal_latvecs = Array([1 0; 2 1]')\natom_types = [0, 1]\natom_pos = Array([0 0; 0.5 0.5]')\ncoords = \"Cartesian\"\nIBZ.Symmetry.calc_spacegroup(real_latvecs,atom_types,atom_pos,coords)\n# output\n(Any[[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]], Any[[0.0 -1.0; -1.0 0.0], [0.0 -1.0; 1.0 0.0], [-1.0 0.0; 0.0 -1.0], [1.0 0.0; 0.0 -1.0], [-1.0 0.0; 0.0 1.0], [1.0 0.0; 0.0 1.0], [0.0 1.0; -1.0 0.0], [0.0 1.0; 1.0 0.0]])\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Symmetry.make_primitive","page":"Documentation","title":"IBZ.Symmetry.make_primitive","text":"make_primitive(real_latvecs,atom_types,atom_pos,coords,rtol,atol)\n\nMake a given unit cell primitive.\n\nThis is a Julia translation of the function by the same in     https://github.com/msg-byu/symlib.\n\nArguments\n\nreal_latvecs::AbstractArray{<:Real,2}: the basis of the lattice as columns   of an array.\natom_types::AbstractArray{<:Int,1}: a list of atom types as integers.\natom_pos::AbstractArray{<:Real,2}: the positions of atoms in the crystal   structure as columns of an array.\ncoords::String: indicates the positions of the atoms are in \"lattice\" or   \"Cartesian\" coordinates.\nrtol::Real=sqrt(eps(float(maximum(real_latvecs)))) a relative tolerance for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\nprim_types::AbstractArray{<:Int,1}: a list of atom types as integers in the   primitive unit cell.\nprim_pos::AbstractArray{<:Real,2}: the positions of the atoms in in the    crystal structure as columns of an array.\nprim_latvecs::AbstractArray{<:Real,2}: the primitive lattice vectors as   columns of an array.\n\nExamples\n\nimport IBZ.Lattices: genlat_CUB\nimport IBZ.Symmetry: make_primitive\na = 1.0\nreal_latvecs = genlat_CUB(a)\natom_types = [0,0]\natom_pos = Array([0 0 0; 0.5 0.5 0.5]')\nibzformat = \"convex hull\"\ncoords = \"Cartesian\"\nconvention = \"ordinary\"\nmake_primitive(real_latvecs, atom_types, atom_pos, coords)\n# output\n([0], [0.0; 0.0; 0.0], [1.0 0.0 0.5; 0.0 1.0 0.5; 0.0 0.0 0.5])\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Symmetry.mapto_unitcell","page":"Documentation","title":"IBZ.Symmetry.mapto_unitcell","text":"mapto_unitcell(pt,latvecs,inv_latvecs,coords,rtol,atol)\n\nMap a point to the first unit (primitive) cell.\n\nArguments\n\npt::AbstractArray{<:Real,1}: a point in lattice or Cartesian coordinates.\nlatvecs::AbstractArray{<:Real,2}: the basis vectors of the lattice as   columns of an array.\ninv_latvecs::AbstractArray{<:Real,2}: the inverse of the matrix of that   contains the lattice vectors.\ncoords::String: indicates whether pt is in \"Cartesian\" or \"lattice\"   coordinates.\nrtol::Real=sqrt(eps(float(maximum(inv_latvecs)))): a relative tolerance for   floating point comparisons. Finite precision errors creep up when pt is   transformed to lattice coordinates because the transformation requires   calculating a matrix inverse. The components of the point in lattice   coordinates are checked to ensure that values close to 1 are equal to 1.\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\nAbstractArray{<:Real,1}: a translationally equivalent point to pt in the   first unit cell in the same coordinates.\n\n#Examples\n\nusing IBZ\nreal_latvecs = [0 1 2; 0 -1 1; 1 0 0]\ninv_latvecs=inv(real_latvecs)\npt=[1,2,3.2]\ncoords = \"Cartesian\"\nIBZ.Symmetry.mapto_unitcell(pt,real_latvecs,inv_latvecs,coords)\n# output\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.20000000000000018\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#Utilities","page":"Documentation","title":"Utilities","text":"","category":"section"},{"location":"Documentation/","page":"Documentation","title":"Documentation","text":"Modules = [IBZ.Utilities]\nOrder   = [:function, :type]","category":"page"},{"location":"Documentation/#IBZ.Utilities.affine_trans-Tuple{AbstractArray{var\"#s153\",2} where var\"#s153\"<:Real}","page":"Documentation","title":"IBZ.Utilities.affine_trans","text":"affine_trans(pts)\n\nCalculate the affine transformation that maps the points to the xy-plane.\n\nArguments\n\npts::AbstractArray{<:Real,2}: an array of Cartesian points as the columns   of a 2D array. The points must all lie on a plane in 3D.\n\nReturns\n\nM::AbstractArray{<:Real,2}: the affine transformation matrix that operates   on points in homogeneous coordinates from the left.\n\nExamples\n\nusing IBZ\npts = [0.5 0.5 0.5; 0.5 -0.5 0.5; -0.5 0.5 0.5; -0.5 -0.5 0.5]'\nIBZ.Utilities.affine_trans(pts)\n# output\n4×4 Array{Float64,2}:\n  0.0  -1.0   0.0  0.5\n -1.0   0.0   0.0  0.5\n  0.0   0.0  -1.0  0.5\n  0.0   0.0   0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Utilities.contains","page":"Documentation","title":"IBZ.Utilities.contains","text":"contains(pt,pts,rtol,atol)\n\nCheck if an array of points contains a point.\n\nArguments\n\npt::AbstractArray{<:Real,1}: a 1D array of reals\npts::AbstractArray{<:Real,2}: a 2D array of reals. Coordinates of points   are the columns of the array.\nrtol::Real=sqrt(eps(float(maximum(pts)))): a relative tolerance for floating   point comparisons\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\nBool: a boolean that indicates the presence or absence of pt in pts.\n\nExamples\n\nimport IBZ.Utilities: contains\npts = Array([1 2; 2 3; 3 4; 4 5]')\npt = [1,2]\ncontains(pt,pts)\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Utilities.contains-2","page":"Documentation","title":"IBZ.Utilities.contains","text":"contains(array,arrays,rtol,atol)\n\nCheck if an array of arrays contains an array.\n\nArguments\n\narray: an array of reals or arbitrary dimension.\narrays: a abstract array of reals of arbitrary dimension.\nrtol::Real=sqrt(eps(float(maximum(pts)))): a relative tolerance for floating   point comparisons.\natol::Real=0.0: an absolute tolerance for floating point comparisons.\n\nReturns\n\nBool: a boolean that indicates the presence of absence of array in   arrays.\n\nExamples\n\nimport IBZ.Utilities: contains\narrays = [[1 2; 2 3], [2 3; 4 5]]\narray = [1 2; 2 3]\ncontains(array, arrays)\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Utilities.edgelengths","page":"Documentation","title":"IBZ.Utilities.edgelengths","text":"edgelengths(basis,radius)\n\nCalculate the edge lengths of a parallelepiped circumscribed by a sphere.\n\nArguments\n\nbasis::Array{<:Real,2}: a 2x2 or 3x3 matrix whose columns give the   parallelogram or parallelepiped directions, respectively.\nradius::Real: the radius of the sphere.\nrtol::Real=sqrt(eps(float(radius))): a relative tolerace for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point   comparisons.\n\nReturns\n\n[la,lb,lc]::Array{Float64,1}: a list of parallelepiped lengths.\n\nExamples\n\nusing IBZ\nbasis=Array([1. 0. 0.; 0. 1. 0.; 0. 0. 1.])\nradius=3.0\nIBZ.Utilities.edgelengths(basis,radius)\n# output\n3-element Array{Float64,1}:\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Utilities.get_uniquefacets-Tuple{Any}","page":"Documentation","title":"IBZ.Utilities.get_uniquefacets","text":"get_uniquefacets(ch)\n\nCalculate the unique facets of a convex hull object.\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Utilities.mapto_xyplane-Tuple{AbstractArray{var\"#s154\",2} where var\"#s154\"<:Real}","page":"Documentation","title":"IBZ.Utilities.mapto_xyplane","text":"function mapto_xyplane(pts)\n\nMap Cartesian points embedded in 3D on a plane to the xy-plane embedded in 2D.\n\nArguments\n\npts::AbstractArray{<:Real,2}: Cartesian points in 3D as columns of a 2D   array.\n\nReturns\n\nAbstractArray{<:Real,2}: Cartesian points in 2D as columns of a 2D array.\n\nExamples\n\nusing IBZ\npts = [0.5 -0.5 0.5; 0.5 -0.5 -0.5; 0.5 0.5 -0.5; 0.5 0.5 0.5]'\nIBZ.Utilities.mapto_xyplane(pts)\n# output\n2×4 Array{Float64,2}:\n 0.0  1.0  1.0  0.0\n 0.0  0.0  1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Utilities.remove_duplicates","page":"Documentation","title":"IBZ.Utilities.remove_duplicates","text":"remove_duplicates(points,rtol,atol)\n\nRemove duplicate points from an array.\n\nArguments\n\npoints::AbstractArray{<:Real,2}: the points are columns of a 2D array.\nrtol::Real=sqrt(eps(float(maximum(points)))): a relative tolerance for   floating point comparisons.\natol::Real=0.0: an absolume tolerance for floating point comparisons.\n\nReturns\n\nuniquepts::AbstractArray{<:Real,2}: a 2D array of unique points as columns.\n\nExamples\n\nusing IBZ\npoints=Array([1 2; 2 3; 3 4; 1 2]')\nIBZ.Utilities.remove_duplicates(points)\n# output\n2×3 Array{Int64,2}:\n 1  2  3\n 2  3  4\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Utilities.sample_circle","page":"Documentation","title":"IBZ.Utilities.sample_circle","text":"sample_circle(basis,radius,offset,rtol,atol)\n\nSample uniformly within a circle centered about a point.\n\nArguments\n\nbasis::Array{<:Real,2}: a 2x2 matrix whose columns are the grid generating   vectors.\nradius::Real: the radius of the circle.\noffset::Array{<:Real,1}=[0.,0.]: the xy-coordinates of the center of the   circle.\nrtol::Real=sqrt(eps(float(radius))): a relative tolerace for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point   comparisons.\n\nReturns\n\npts::Array{Float64,2} a matrix whose columns are sample points in Cartesian   coordinates.\n\nExamples\n\nusing IBZ\nbasis=Array([1. 0.; 0. 1.]')\nradius=1.0\noffset=[0.,0.]\nIBZ.Utilities.sample_circle(basis,radius,offset)\n# output\n2×5 Array{Float64,2}:\n  0.0  -1.0  0.0  1.0  0.0\n -1.0   0.0  0.0  0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Utilities.sample_sphere","page":"Documentation","title":"IBZ.Utilities.sample_sphere","text":"sample_sphere(basis,radius,offset,rtol,atol)\n\nSample uniformly within a circle centered about a point.\n\nArguments\n\nbasis::Array{<:Real,2}: a 3x3 matrix whose columns are the grid generating   vectors.\nradius::Real: the radius of the sphere.\noffset::Array{<:Real,1}=[0.,0.]: the xy-coordinates of the center of the   circle.\nrtol::Real=sqrt(eps(float(radius))): a relative tolerace for   floating point comparisons.\natol::Real=0.0: an absolute tolerance for floating point   comparisons.\n\nReturns\n\npts::Array{Float64,2} a matrix whose columns are sample points in Cartesian   coordinates.\n\nExamples\n\nusing IBZ\nbasis=Array([1. 0. 0.; 0. 1. 0.; 0. 0. 1.])\nradius=1.0\noffset=[0.,0.,0.]\nIBZ.Utilities.sample_sphere(basis,radius,offset)\n# output\n3×7 Array{Float64,2}:\n  0.0   0.0  -1.0  0.0  1.0  0.0  0.0\n  0.0  -1.0   0.0  0.0  0.0  1.0  0.0\n -1.0   0.0   0.0  0.0  0.0  0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"Documentation/#IBZ.Utilities.shoelace-Tuple{Any}","page":"Documentation","title":"IBZ.Utilities.shoelace","text":"shoelace(vertices)\n\nCalculate the area of a polygon with the shoelace algorithm.\n\nArguments\n\nvertices::AbstractArray{<:Real,2}: the xy-coordinates of the vertices   of the polygon as the columns of a 2D array.\n\nReturns\n\n<:Real: the area of the polygon.\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Utilities.sort_points_comparison-Tuple{AbstractArray{var\"#s127\",1} where var\"#s127\"<:Real,AbstractArray{var\"#s126\",1} where var\"#s126\"<:Real,AbstractArray{var\"#s125\",1} where var\"#s125\"<:Real}","page":"Documentation","title":"IBZ.Utilities.sort_points_comparison","text":"function sort_points_comparison(a,b,c)\n\nA \"less than\" function for sorting Cartesian points in 2D.\n\nArguments\n\na::AbstractArray{<:Real,1}: a point in Cartesian coordinates.\nb::AbstractArray{<:Real,1}: a point in Cartesian coordinates.\nc::AbstractArray{<:Real,1}: the position of the origin in Cartesian   coordinates.\n\nReturns\n\nBool: a boolean that indicates if a is less than b.\n\nExamples\n\nusing IBZ\na=[0,0]\nb=[1,0]\nc=[0.5,0.5]\nIBZ.Utilities.sort_points_comparison(a,b,c)\n# output\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Utilities.sortpts_perm-Tuple{AbstractArray{var\"#s155\",2} where var\"#s155\"<:Real}","page":"Documentation","title":"IBZ.Utilities.sortpts_perm","text":"function sortpts_perm(pts)\n\nCalculate the permutation vector that sorts Cartesian points embedded in 3D that     lie on a plane (counter)clockwise with respect to the average of all points.\n\nArguments\n\npts::AbstractArray{<:Real,2}: Cartesian points embedded in 3D that all lie   on a plane. The points are columns of a 2D array.\n\nReturns\n\nperm::AbstractArray{<:Real,1}: the permutation vector that orders the points   clockwise or counterclockwise.\n\nExamples\n\nusing IBZ\npts = [0.5 -0.5 0.5; 0.5 -0.5 -0.5; 0.5 0.5 -0.5; 0.5 0.5 0.5]'\nperm=IBZ.Utilities.sortpts_perm(pts)\npts[:,perm]\n# output\n3×4 Array{Float64,2}:\n  0.5  0.5   0.5   0.5\n  0.5  0.5  -0.5  -0.5\n -0.5  0.5   0.5  -0.5\n\n\n\n\n\n","category":"method"},{"location":"Documentation/#IBZ.Utilities.sortslice_perm-Tuple{AbstractArray{var\"#s142\",2} where var\"#s142\"<:Real,AbstractArray{var\"#s127\",2} where var\"#s127\"<:Real}","page":"Documentation","title":"IBZ.Utilities.sortslice_perm","text":"function sortslice_perm(xypts,sxypts)\n\nReturn the permutation vector that maps Cartesian 2D points xypts to sxypts.\n\nArguments\n\nxypts::AbstractArray{<:Real,2}: 2D Cartesian points as columns of a 2D   array.\nsxypts::AbstractArray{<:Real,2}: sorted 2D Cartesian points as columns of a   2D array.\n\nReturns\n\nperm::AbstractArray{<:Real,1}: a permutation vector that sorts an array of   2D Cartesian coordinates.\n\nExamples\n\nusing IBZ\nxypts = [0 0; 0 1; 1 0; 1 1]'\nsxypts = [0 1; 1 1; 1 0; 0 0]'\nperm=IBZ.Utilities.sortslice_perm(xypts,sxypts)\nxypts[:,perm]\n# output\n2×4 Array{Int64,2}:\n 0  1  1  0\n 1  1  0  0\n\n\n\n\n\n","category":"method"},{"location":"Usage/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"Usage/","page":"User guide","title":"User guide","text":"IBZ.jl calculates the irreducible Brillouin zone (IBZ) of a crystal structure in 2D and 3D. It also contains functions related to the symmetry of lattices and lattice reduction. Later on, it will be able to calculate high symmetry points and paths within the IBZ.","category":"page"},{"location":"Usage/","page":"User guide","title":"User guide","text":"To calculate the IBZ, simply provide the lattice and atomic basis to calc_ibz. The IBZ will be returned as either a convex hull or intersection of half spaces.","category":"page"},{"location":"Usage/","page":"User guide","title":"User guide","text":"import IBZ.Lattices: genlat_CUB\nimport IBZ.Symmetry: calc_ibz\na = 2.0\nreal_latvecs = genlat_CUB(a)\natom_types = [0,0]\natom_pos = Array([0 0 0; 0.5 0.5 0.5]')\nibzformat = \"convex hull\"\ncoordinates = \"Cartesian\"\nconvention = \"ordinary\"\nibz = calc_ibz(real_latvecs,atom_types,atom_pos,coordinates,ibzformat,\n  convention)","category":"page"},{"location":"Usage/","page":"User guide","title":"User guide","text":"The columns of real_latvecs are the lattice generating vectors, the columns of atom_pos are the positions of the atoms in Cartesian coordinates (in this case), coordinates are the coordinates of the atom positions, and convention gives the convention for going from real to reciprocal space (whether or not to multiply by 2π). There is a simple function for visualizing the IBZ along with the Brillouin zone (BZ).","category":"page"},{"location":"Usage/","page":"User guide","title":"User guide","text":"import IBZ.Plotting: plot_convexhulls\nimport IBZ.Lattices: genlat_CUB\na = 2.0\nreal_latvecs = genlat_CUB(a)\natom_types = [0,0]\natom_pos = Array([0 0 0; 0.5 0.5 0.5]')\ncoordinates = \"Cartesian\"\nconvention = \"ordinary\"\n(fix,ax)=plot_convexhulls(real_latvecs,atom_types,atom_pos,coordinates,\n  convention)","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IBZ.jl is a julia package for calculating the irreducible Brillouin zone. It also contains methods related to the symmetry of lattices and lattice reduction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"Usage.md\", \"Documentation.md\"]\ndepth = 5","category":"page"}]
}
