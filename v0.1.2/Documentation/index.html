<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · SymmetryReduceBZ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SymmetryReduceBZ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../Usage/">User guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/master/docs/src/Documentation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><h3 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Lattices.check_reduced-Tuple{AbstractArray{var&quot;#s14&quot;,2} where var&quot;#s14&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.check_reduced</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_BCC"><code>SymmetryReduceBZ.Lattices.genlat_BCC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_BCT"><code>SymmetryReduceBZ.Lattices.genlat_BCT</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_CUB"><code>SymmetryReduceBZ.Lattices.genlat_CUB</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_FCC"><code>SymmetryReduceBZ.Lattices.genlat_FCC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_HEX"><code>SymmetryReduceBZ.Lattices.genlat_HEX</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_HXG"><code>SymmetryReduceBZ.Lattices.genlat_HXG</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_MCL"><code>SymmetryReduceBZ.Lattices.genlat_MCL</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_MCLC"><code>SymmetryReduceBZ.Lattices.genlat_MCLC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_OBL"><code>SymmetryReduceBZ.Lattices.genlat_OBL</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORC"><code>SymmetryReduceBZ.Lattices.genlat_ORC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORCC"><code>SymmetryReduceBZ.Lattices.genlat_ORCC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORCF"><code>SymmetryReduceBZ.Lattices.genlat_ORCF</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_ORCI"><code>SymmetryReduceBZ.Lattices.genlat_ORCI</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_REC"><code>SymmetryReduceBZ.Lattices.genlat_REC</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_RECI"><code>SymmetryReduceBZ.Lattices.genlat_RECI</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_RHL"><code>SymmetryReduceBZ.Lattices.genlat_RHL</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_SQR"><code>SymmetryReduceBZ.Lattices.genlat_SQR</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_TET"><code>SymmetryReduceBZ.Lattices.genlat_TET</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.genlat_TRI"><code>SymmetryReduceBZ.Lattices.genlat_TRI</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.get_latparams-Tuple{Any}"><code>SymmetryReduceBZ.Lattices.get_latparams</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.get_recip_latvecs"><code>SymmetryReduceBZ.Lattices.get_recip_latvecs</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.minkowski_reduce-Tuple{AbstractArray{var&quot;#s15&quot;,2} where var&quot;#s15&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.minkowski_reduce</code></a></li><li><a href="#SymmetryReduceBZ.Lattices.reduce_basis!-Tuple{AbstractArray{var&quot;#s17&quot;,2} where var&quot;#s17&quot;&lt;:Real,Int64}"><code>SymmetryReduceBZ.Lattices.reduce_basis!</code></a></li></ul><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Plotting.plot_2Dconvexhull-Tuple{QHull.Chull{var&quot;#s157&quot;} where var&quot;#s157&quot;&lt;:Real,PyCall.PyObject,String}"><code>SymmetryReduceBZ.Plotting.plot_2Dconvexhull</code></a></li><li><a href="#SymmetryReduceBZ.Plotting.plot_3Dconvexhull-Tuple{QHull.Chull{var&quot;#s159&quot;} where var&quot;#s159&quot;&lt;:Real,PyCall.PyObject,String}"><code>SymmetryReduceBZ.Plotting.plot_3Dconvexhull</code></a></li><li><a href="#SymmetryReduceBZ.Plotting.plot_convexhulls"><code>SymmetryReduceBZ.Plotting.plot_convexhulls</code></a></li></ul><h3 id="Symmetry"><a class="docs-heading-anchor" href="#Symmetry">Symmetry</a><a id="Symmetry-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetry" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Symmetry.calc_bz"><code>SymmetryReduceBZ.Symmetry.calc_bz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.calc_ibz"><code>SymmetryReduceBZ.Symmetry.calc_ibz</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.calc_pointgroup"><code>SymmetryReduceBZ.Symmetry.calc_pointgroup</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.calc_spacegroup"><code>SymmetryReduceBZ.Symmetry.calc_spacegroup</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.inhull"><code>SymmetryReduceBZ.Symmetry.inhull</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.make_primitive"><code>SymmetryReduceBZ.Symmetry.make_primitive</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_BZ"><code>SymmetryReduceBZ.Symmetry.mapto_BZ</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_IBZ"><code>SymmetryReduceBZ.Symmetry.mapto_IBZ</code></a></li><li><a href="#SymmetryReduceBZ.Symmetry.mapto_unitcell"><code>SymmetryReduceBZ.Symmetry.mapto_unitcell</code></a></li></ul><h3 id="Utilites"><a class="docs-heading-anchor" href="#Utilites">Utilites</a><a id="Utilites-1"></a><a class="docs-heading-anchor-permalink" href="#Utilites" title="Permalink"></a></h3><ul><li><a href="#SymmetryReduceBZ.Utilities.affine_trans-Tuple{AbstractArray{var&quot;#s158&quot;,2} where var&quot;#s158&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.affine_trans</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.contains"><code>SymmetryReduceBZ.Utilities.contains</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.contains"><code>SymmetryReduceBZ.Utilities.contains</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.edgelengths"><code>SymmetryReduceBZ.Utilities.edgelengths</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Any}"><code>SymmetryReduceBZ.Utilities.get_uniquefacets</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.mapto_xyplane-Tuple{AbstractArray{var&quot;#s159&quot;,2} where var&quot;#s159&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.mapto_xyplane</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.remove_duplicates"><code>SymmetryReduceBZ.Utilities.remove_duplicates</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sample_circle"><code>SymmetryReduceBZ.Utilities.sample_circle</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sample_sphere"><code>SymmetryReduceBZ.Utilities.sample_sphere</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.shoelace-Tuple{Any}"><code>SymmetryReduceBZ.Utilities.shoelace</code></a></li><li><a href="#SymmetryReduceBZ.Utilities.sortpts_perm-Tuple{AbstractArray{var&quot;#s158&quot;,2} where var&quot;#s158&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.sortpts_perm</code></a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="Lattices-2"><a class="docs-heading-anchor" href="#Lattices-2">Lattices</a><a class="docs-heading-anchor-permalink" href="#Lattices-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.check_reduced-Tuple{AbstractArray{var&quot;#s14&quot;,2} where var&quot;#s14&quot;&lt;:Real}" href="#SymmetryReduceBZ.Lattices.check_reduced-Tuple{AbstractArray{var&quot;#s14&quot;,2} where var&quot;#s14&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.check_reduced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_reduced(basis)</code></pre><p>Verify a lattice basis is Minkowski reduced</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractArray{&lt;:Real,2}</code>: the lattice basis given by the columns   of a 2x2 or 3x3 matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: a boolean that indicates if the lattice basis is reduced.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis = [1 0; 0 1]
SymmetryReduceBZ.Lattices.check_reduced(basis)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L211-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_BCC" href="#SymmetryReduceBZ.Lattices.genlat_BCC"><code>SymmetryReduceBZ.Lattices.genlat_BCC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_BCC(a)</code></pre><p>Generate a body-centered cubic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_BCC(a)
# output
3×3 Array{Float64,2}:
 -0.5   0.5   0.5
  0.5  -0.5   0.5
  0.5   0.5  -0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L496-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_BCT" href="#SymmetryReduceBZ.Lattices.genlat_BCT"><code>SymmetryReduceBZ.Lattices.genlat_BCT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_BCT(a,c)</code></pre><p>Generate a body-centered tetragonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
c=1.2;
SymmetryReduceBZ.Lattices.genlat_BCT(a,c)
# output
3×3 Array{Float64,2}:
 -0.5   0.5   0.5
  0.5  -0.5   0.5
  0.6   0.6  -0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L568-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_CUB" href="#SymmetryReduceBZ.Lattices.genlat_CUB"><code>SymmetryReduceBZ.Lattices.genlat_CUB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_CUB(a)</code></pre><p>Generate a simple cubic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_CUB(a)
# output
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L431-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_FCC" href="#SymmetryReduceBZ.Lattices.genlat_FCC"><code>SymmetryReduceBZ.Lattices.genlat_FCC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_FCC(a)</code></pre><p>Generate a face-centered cubic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_FCC(a)
# output
3×3 Array{Float64,2}:
 0.0  0.5  0.5
 0.5  0.0  0.5
 0.5  0.5  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L460-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_HEX" href="#SymmetryReduceBZ.Lattices.genlat_HEX"><code>SymmetryReduceBZ.Lattices.genlat_HEX</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_HEX(a,c)</code></pre><p>Generate a hexagonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
c=1.2;
SymmetryReduceBZ.Lattices.genlat_HEX(a,c)
# output
3×3 Array{Float64,2}:
  0.5       0.5       0.0
 -0.866025  0.866025  0.0
  0.0       0.0       1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L787-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_HXG" href="#SymmetryReduceBZ.Lattices.genlat_HXG"><code>SymmetryReduceBZ.Lattices.genlat_HXG</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_HXG(a)</code></pre><p>Generate a 2D hexagonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_HXG(a)
# output
2×2 Array{Float64,2}:
 1.0  -0.5
 0.0   0.866025</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L290-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_MCL" href="#SymmetryReduceBZ.Lattices.genlat_MCL"><code>SymmetryReduceBZ.Lattices.genlat_MCL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_MCL(a,b,c,α)</code></pre><p>Generate a monoclinic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians less than π/2</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2
c=1.4
α=π/6;
SymmetryReduceBZ.Lattices.genlat_MCL(a,b,c,α)
# output
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.2  1.21244
 0.0  0.0  0.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L860-L890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_MCLC" href="#SymmetryReduceBZ.Lattices.genlat_MCLC"><code>SymmetryReduceBZ.Lattices.genlat_MCLC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_MCLC(a,b,c,α)</code></pre><p>Generate a base-centered monoclinic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians less than π/2</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2
c=1.4
α=π/6;
SymmetryReduceBZ.Lattices.genlat_MCLC(a,b,c,α)
# output
3×3 Array{Float64,2}:
 0.5  -0.5  0.0
 0.6   0.6  1.21244
 0.0   0.0  0.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L903-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_OBL" href="#SymmetryReduceBZ.Lattices.genlat_OBL"><code>SymmetryReduceBZ.Lattices.genlat_OBL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_OBL(a,b,θ)</code></pre><p>Generate an oblique lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>b::Real</code>: the lattice constant</li><li><code>θ::Real</code>: the lattice angle</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2
θ=π/3
SymmetryReduceBZ.Lattices.genlat_OBL(a,b,θ)
# output
2×2 Array{Float64,2}:
 1.0  0.6
 0.0  1.03923</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L390-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORC" href="#SymmetryReduceBZ.Lattices.genlat_ORC"><code>SymmetryReduceBZ.Lattices.genlat_ORC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_ORC(a,b,c)</code></pre><p>Generate an orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.4;
c=1.2;
SymmetryReduceBZ.Lattices.genlat_ORC(a,b,c)
# output
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.4  0.0
 0.0  0.0  1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L611-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORCC" href="#SymmetryReduceBZ.Lattices.genlat_ORCC"><code>SymmetryReduceBZ.Lattices.genlat_ORCC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_ORCC(a,b,c)</code></pre><p>Generate a base-centered orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2;
c=1.4;
SymmetryReduceBZ.Lattices.genlat_ORCC(a,b,c)
# output
3×3 Array{Float64,2}:
  0.5  0.5  0.0
 -0.6  0.6  0.0
  0.0  0.0  1.4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L741-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORCF" href="#SymmetryReduceBZ.Lattices.genlat_ORCF"><code>SymmetryReduceBZ.Lattices.genlat_ORCF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_ORCF(a,b,c)</code></pre><p>Generate a face-centered orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.4;
c=1.2;
SymmetryReduceBZ.Lattices.genlat_ORCF(a,b,c)
# output
3×3 Array{Float64,2}:
 0.0  0.5  0.5
 0.7  0.0  0.7
 0.6  0.6  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L649-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_ORCI" href="#SymmetryReduceBZ.Lattices.genlat_ORCI"><code>SymmetryReduceBZ.Lattices.genlat_ORCI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_ORCI(a,b,c)</code></pre><p>Generate a body-centered orthorhombic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.4;
c=1.2;
SymmetryReduceBZ.Lattices.genlat_ORCI(a,b,c)
# output
3×3 Array{Float64,2}:
 -0.5   0.5   0.5
  0.7  -0.7   0.7
  0.6   0.6  -0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L695-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_REC" href="#SymmetryReduceBZ.Lattices.genlat_REC"><code>SymmetryReduceBZ.Lattices.genlat_REC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_REC(a,b)</code></pre><p>Generate a rectangular lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2
SymmetryReduceBZ.Lattices.genlat_REC(a,b)
# output
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L318-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_RECI" href="#SymmetryReduceBZ.Lattices.genlat_RECI"><code>SymmetryReduceBZ.Lattices.genlat_RECI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_RECI(a,b)</code></pre><p>Generate a body-centered rectangular lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2
SymmetryReduceBZ.Lattices.genlat_RECI(a,b)
# output
2×2 Array{Float64,2}:
  0.5  0.5
 -0.6  0.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L348-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_RHL" href="#SymmetryReduceBZ.Lattices.genlat_RHL"><code>SymmetryReduceBZ.Lattices.genlat_RHL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_RHL(a,α)</code></pre><p>Generate a rhombohedral lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
α=π/6;
SymmetryReduceBZ.Lattices.genlat_RHL(a,α)
# output
3×3 Array{Float64,2}:
  0.965926  0.965926  0.896575
 -0.258819  0.258819  0.0
  0.0       0.0       0.442891</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L823-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_SQR" href="#SymmetryReduceBZ.Lattices.genlat_SQR"><code>SymmetryReduceBZ.Lattices.genlat_SQR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_SQR(a)</code></pre><p>Generate a square lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: the lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
SymmetryReduceBZ.Lattices.genlat_SQR(a)
# output
2×2 Array{Int64,2}:
 1  0
 0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L262-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_TET" href="#SymmetryReduceBZ.Lattices.genlat_TET"><code>SymmetryReduceBZ.Lattices.genlat_TET</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_TET(a,c)</code></pre><p>Generate a simple tetragonal lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
c=1.2;
SymmetryReduceBZ.Lattices.genlat_TET(a,c)
# output
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L532-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.genlat_TRI" href="#SymmetryReduceBZ.Lattices.genlat_TRI"><code>SymmetryReduceBZ.Lattices.genlat_TRI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genlat_TRI(a,b,c,α,β,γ)</code></pre><p>Generate a triclinic lattice.</p><p><strong>Arguments</strong></p><ul><li><code>a::Real</code>: a lattice constant</li><li><code>b::Real</code>: a lattice constant</li><li><code>c::Real</code>: a lattice constant</li><li><code>α::Real</code>: a lattice angle in radians</li><li><code>β::Real</code>: a lattice angle in radians</li><li><code>γ::Real</code>: a lattice angle in radians</li><li><code>type::String=&quot;primitive&quot;</code>: the lattice type: &quot;primitive&quot; or &quot;conventional&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
a=1
b=1.2
c=1.4
α=π/6;
β=π/3;
γ=π/4;
SymmetryReduceBZ.Lattices.genlat_TRI(a,b,c,α,β,γ)
# output
3×3 Array{Float64,2}:
 1.0  0.848528  0.7
 0.0  0.848528  1.01464
 0.0  0.0       0.663702</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L953-L987">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.get_latparams-Tuple{Any}" href="#SymmetryReduceBZ.Lattices.get_latparams-Tuple{Any}"><code>SymmetryReduceBZ.Lattices.get_latparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_latparams(latvecs)</code></pre><p>Calculate the lattice constants and angles of a lattice basis.</p><p><strong>Arguments</strong></p><ul><li><code>latvecs::AbstractArray{&lt;:Real,2}</code>: the lattice basis as columns of an array.</li></ul><p><strong>Returns</strong></p><ul><li>A list where the first element is a list lattice constants <code>(a,b,c)</code> and second   lattice angles in radians <code>(α,β,γ)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
latvecs = [1 0; 0 1]
SymmetryReduceBZ.Lattices.get_latparams(latvecs)
# output
2-element Array{Array{Float64,1},1}:
 [1.0, 1.0]
 [1.5707963267948966, 1.5707963267948966]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L56-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.get_recip_latvecs" href="#SymmetryReduceBZ.Lattices.get_recip_latvecs"><code>SymmetryReduceBZ.Lattices.get_recip_latvecs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_recip_latvecs(real_latvecs, convention)</code></pre><p>Calculate the reciprocal lattice vectors.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractArray{&lt;:Real,2}</code>: the real-space lattice vectors or   primitive translation vectors as columns of a 2x2 or 3x3 array.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li></ul><p><strong>Returns</strong></p><ul><li><code>recip_latvecs::Array{&lt;:Real,2}</code> the reciprocal lattice vectors (reciprocal   primitive translation vectors) as columns of a 2x2 or 3x3 array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
real_latvecs=[1 0 0; 0 1 0; 0 0 1]
convention=&quot;angular&quot;
SymmetryReduceBZ.Lattices.get_recip_latvecs(real_latvecs,convention)
# output
3×3 Array{Float64,2}:
 6.28319  0.0      0.0
 0.0      6.28319  0.0
 0.0      0.0      6.28319</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L13-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.minkowski_reduce-Tuple{AbstractArray{var&quot;#s15&quot;,2} where var&quot;#s15&quot;&lt;:Real}" href="#SymmetryReduceBZ.Lattices.minkowski_reduce-Tuple{AbstractArray{var&quot;#s15&quot;,2} where var&quot;#s15&quot;&lt;:Real}"><code>SymmetryReduceBZ.Lattices.minkowski_reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    minkowski_reduce(basis)</code></pre><p>Minkowski reduce a lattice basis. Follows the logic of Fig. 4 in &quot;Low-Dimensional Lattice Basis Reduction Revisited&quot; by Nguyen, 2009.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractArray{&lt;:Real,2}</code>: the lattice basis given by the columns   of a 2x2 or 3x3 array.</li></ul><p><strong>Returns</strong></p><ul><li>`rbasis:: the Minkowski reduced lattice basis as columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis = [1 2 0; 0 1 0; 0 0 1]
SymmetryReduceBZ.Lattices.minkowski_reduce(basis)
# output
3×3 Array{Int64,2}:
 0  1  0
 0  0  1
 1  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L172-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Lattices.reduce_basis!-Tuple{AbstractArray{var&quot;#s17&quot;,2} where var&quot;#s17&quot;&lt;:Real,Int64}" href="#SymmetryReduceBZ.Lattices.reduce_basis!-Tuple{AbstractArray{var&quot;#s17&quot;,2} where var&quot;#s17&quot;&lt;:Real,Int64}"><code>SymmetryReduceBZ.Lattices.reduce_basis!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_basis!(basis,k)</code></pre><p>Reduces the <code>k</code>th lattice vector. This is accomplished by locating the lattice point closest to the projection of the <code>k</code>th lattice vector onto the line or plane given by the other lattice vector(s), subtracting the closest lattice point from the <code>k</code>th lattice vector, and reordering the lattice vectors by increasing Euclidean norms.</p><p><strong>Arguments</strong></p><ul><li><code>basis::AbstractArray{&lt;:Real,2}</code>: the lattice basis as columns of an array.</li><li><code>k::Int</code>: Keeps track of which lattice vector needs to be reduced.</li></ul><p><strong>Returns</strong></p><ul><li><code>basis::AbstractArray{&lt;:Real,2}</code>: the partially reduced lattice basis as   columns of an array.</li><li><code>k::Int</code>: The index of the lattice vector that needs to be reduced next.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis = Array([1 2 0; 0 1 0; 3 2 1]&#39;)
k=2
SymmetryReduceBZ.Lattices.reduce_basis!(basis,k)
basis
# output
3×3 Array{Int64,2}:
 0  1  3
 1  2  2
 0  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Lattices.jl#L96-L127">source</a></section></article><h3 id="Plotting-2"><a class="docs-heading-anchor" href="#Plotting-2">Plotting</a><a class="docs-heading-anchor-permalink" href="#Plotting-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Plotting.plot_2Dconvexhull-Tuple{QHull.Chull{var&quot;#s157&quot;} where var&quot;#s157&quot;&lt;:Real,PyCall.PyObject,String}" href="#SymmetryReduceBZ.Plotting.plot_2Dconvexhull-Tuple{QHull.Chull{var&quot;#s157&quot;} where var&quot;#s157&quot;&lt;:Real,PyCall.PyObject,String}"><code>SymmetryReduceBZ.Plotting.plot_2Dconvexhull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_2Dconvexhull(convexhull, ax, color)</code></pre><p>Plot a 2D convex hull</p><p><strong>Arguments</strong></p><ul><li><code>convexhull::Chull{&lt;:Real}</code>: a convex hull object.</li><li><code>ax::PyObject</code>: an axes object from matplotlib.</li><li><code>color::String</code>: the face color of the convex hull.</li></ul><p><strong>Returns</strong></p><ul><li><code>ax::PyObject</code>: updated <code>ax</code> that includes a plot of the convex hull.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using SymmetryReduceBZ
real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coords = &quot;Cartesian&quot;
ibzformat = &quot;convex hull&quot;
primitive=false
ibz = SymmetryReduceBZ.Symmetry.calc_ibz(real_latvecs,atom_types,atom_pos,coords,
	ibzformat,primitive,convention)
fig,ax=subplots(figsize=figaspect(1)*1.5)
color=&quot;deepskyblue&quot;
ax = SymmetryReduceBZ.Plotting.plot_2Dconvexhull(ibz,ax,color);
SymmetryReduceBZ.Plotting.plot_2Dconvexhull(bz,ax,color)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Plotting.jl#L14-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Plotting.plot_3Dconvexhull-Tuple{QHull.Chull{var&quot;#s159&quot;} where var&quot;#s159&quot;&lt;:Real,PyCall.PyObject,String}" href="#SymmetryReduceBZ.Plotting.plot_3Dconvexhull-Tuple{QHull.Chull{var&quot;#s159&quot;} where var&quot;#s159&quot;&lt;:Real,PyCall.PyObject,String}"><code>SymmetryReduceBZ.Plotting.plot_3Dconvexhull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot_3Dconvexhull(convexhull, ax, color)</code></pre><p>Plot a 3D convex hull</p><p><strong>Arguments</strong></p><ul><li><code>convexhull::Chull{&lt;:Real}</code>: a convex hull object.</li><li><code>ax::PyObject</code>: an axes object from matplotlib.</li><li><code>color::String</code>: the face color of the convex hull.</li><li><code>plotrange=false</code>: the range over which to plot the convex hull.</li></ul><p><strong>Returns</strong></p><ul><li><code>ax::PyObject</code>: updated <code>ax</code> that includes a plot of the convex hull.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using SymmetryReduceBZ
real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coords = &quot;Cartesian&quot;
bzformat = &quot;convex hull&quot;
primitive=false
bz = SymmetryReduceBZ.Symmetry.calc_bz(real_latvecs,atom_types,atom_pos,coords,
    bzformat,primitive,convention)
fig = figure(figsize=figaspect(1)*1.5)
ax = fig.add_subplot(111, projection=&quot;3d&quot;)
ax = SymmetryReduceBZ.Plotting.plot_3Dconvexhull(bz,ax,&quot;deepskyblue&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Plotting.jl#L65-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Plotting.plot_convexhulls" href="#SymmetryReduceBZ.Plotting.plot_convexhulls"><code>SymmetryReduceBZ.Plotting.plot_convexhulls</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot_convexhulls(real_latvecs,atom_types,atom_pos,coords,primitive,
    convention,rtol,atol)</code></pre><p>Plot the Brillouin and Irreducible Brillouin zone in 2D or 3D.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractArray{&lt;:Real,2}</code>: the basis of a real-space lattice as   columns of an array.</li><li><code>atom_types:AbstractArray{&lt;:Int,1}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractArray{&lt;:Real,2}</code>: the positions of atoms in the crystal   structure as columns of an array.</li><li><code>coords::String</code>: indicates the positions of the atoms are in &quot;lattice&quot; or   &quot;Cartesian&quot; coordinates.</li><li><code>primitive::Bool=false</code>: make the unit cell primitive before calculating the   the IBZ if equal to <code>true</code>.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>(fig,ax)</code>: the figure and axes Python objects.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using SymmetryReduceBZ
real_latvecs = [1 0; .5 1]
atom_types=[0]
coords = &quot;Cartesian&quot;
atom_pos = Array([0 0]&#39;)
convention = &quot;ordinary&quot;
(fig,ax)=plot_convexhulls(real_latvecs,atom_types,atom_pos,coords,convention)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Plotting.jl#L129-L166">source</a></section></article><h3 id="Symmetry-2"><a class="docs-heading-anchor" href="#Symmetry-2">Symmetry</a><a class="docs-heading-anchor-permalink" href="#Symmetry-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_bz" href="#SymmetryReduceBZ.Symmetry.calc_bz"><code>SymmetryReduceBZ.Symmetry.calc_bz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_bz(real_latvecs,atom_types,atom_pos,coords,bzformat,makeprim,
	convention,rtol,atol)</code></pre><p>Calculate the Brillouin zone for the given real-space lattice basis.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractArray{&lt;:Real,2}</code>: the real-space lattice vectors or</li></ul><pre><code class="language-none">primitive translation vectors as columns of a 2x2 or 3x3 array.</code></pre><ul><li><code>atom_types:AbstractArray{&lt;:Int,1}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractArray{&lt;:Real,2}</code>: the positions of atoms in the crystal</li></ul><pre><code class="language-none">structure as columns of an array.</code></pre><ul><li><code>coords::String</code>: indicates the positions of the atoms are in &quot;lattice&quot; or</li></ul><pre><code class="language-none">&quot;Cartesian&quot; coordinates.</code></pre><ul><li><code>bzformat::String</code>: the format of the Brillouin zone. Options include</li></ul><pre><code class="language-none">&quot;convex-hull&quot; and &quot;half-space&quot;.</code></pre><ul><li><code>makeprim::Bool=false</code>: make the unit cell primitive before calculating the</li></ul><pre><code class="language-none">the BZ if equal to `true`.</code></pre><ul><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and</li></ul><pre><code class="language-none">reciprocal space. The two conventions are ordinary (temporal) frequency and
angular frequency. The transformation from real to reciprocal space is
unitary if the convention is ordinary.</code></pre><ul><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for</li></ul><pre><code class="language-none">floating point comparisons.</code></pre><ul><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>bz</code>: the vertices or half-space representation of the Brillouin zone</li></ul><pre><code class="language-none">depending on the value of `vertsOrHrep`.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coords = &quot;Cartesian&quot;
bzformat = &quot;convex hull&quot;
makeprim=false
SymmetryReduceBZ.Symmetry.calc_bz(real_latvecs,atom_types,atom_pos,coords,
	bzformat,makeprim,convention)
# output
Convex Hull of 4 points in 2 dimensions
Hull segment vertex indices:
[3, 2, 1, 4]
Points on convex hull in original order:

[0.5 0.5; 0.5 -0.5; -0.5 -0.5; -0.5 0.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L461-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_ibz" href="#SymmetryReduceBZ.Symmetry.calc_ibz"><code>SymmetryReduceBZ.Symmetry.calc_ibz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_ibz(real_latvecs,atom_types,atom_pos,coords,ibzformat,makeprim,
	convention,rtol,atol)</code></pre><p>Calculate the irreducible Brillouin zone of a crystal structure in 2D or 3D.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractArray{&lt;:Real,2}</code>: the basis of a real-space lattice as   columns of an array.</li><li><code>atom_types:AbstractArray{&lt;:Int,1}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractArray{&lt;:Real,2}</code>: the positions of atoms in the crystal   structure as columns of an array.</li><li><code>coords::String</code>: indicates the positions of the atoms are in &quot;lattice&quot; or   &quot;Cartesian&quot; coordinates.</li><li><code>ibzformat::String</code>: the format of the irreducible Brillouin zone. Options   include &quot;convex-hull&quot; and &quot;half-space&quot;.</li><li><code>convention::String=&quot;ordinary&quot;</code>: the convention used to go between real and   reciprocal space. The two conventions are ordinary (temporal) frequency and   angular frequency. The transformation from real to reciprocal space is   unitary if the convention is ordinary.</li><li><code>makeprim::Bool=false</code>: make the unit cell primitive before calculating the</li></ul><pre><code class="language-none">the IBZ if true.</code></pre><ul><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>ibz</code>: the irreducible Brillouin zone as a convex hull or intersection of   half-spaces.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
real_latvecs = [1 0; 0 1]
convention=&quot;ordinary&quot;
atom_types=[0]
atom_pos = Array([0 0]&#39;)
coords = &quot;Cartesian&quot;
ibzformat = &quot;convex hull&quot;
makeprim=false
SymmetryReduceBZ.Symmetry.calc_ibz(real_latvecs,atom_types,atom_pos,coords,
	ibzformat,makeprim,convention)
# output
Convex Hull of 3 points in 2 dimensions
Hull segment vertex indices:
[1, 2, 3]
Points on convex hull in original order:

[0.0 0.0; 0.5 0.0; 0.5 0.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L556-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_pointgroup" href="#SymmetryReduceBZ.Symmetry.calc_pointgroup"><code>SymmetryReduceBZ.Symmetry.calc_pointgroup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_pointgroup(latvecs,rtol,atol)</code></pre><p>Calculate the point group of lattice in 2D or 3D.</p><p><strong>Arguments</strong></p><ul><li><code>latvecs::AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as columns of an   array.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code>: a relative tolerance for   floating point comparisons. It is used to compare lengths of vectors and the   volumes of primitive cells.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons. It is   used to compare lengths of vectors and the volumes of primitive cells.</li></ul><p><strong>Returns</strong></p><ul><li><code>pointgroup::Array{Array{Float64,2},1}</code>: the point group of the lattice. The   operators operate on points in Cartesian coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis = [1 0; 0 1]
SymmetryReduceBZ.Symmetry.calc_pointgroup(basis)
# output
8-element Array{Array{Float64,2},1}:
 [0.0 -1.0; -1.0 0.0]
 [0.0 -1.0; 1.0 0.0]
 [-1.0 0.0; 0.0 -1.0]
 [1.0 0.0; 0.0 -1.0]
 [-1.0 0.0; 0.0 1.0]
 [1.0 0.0; 0.0 1.0]
 [0.0 1.0; -1.0 0.0]
 [0.0 1.0; 1.0 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L15-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.calc_spacegroup" href="#SymmetryReduceBZ.Symmetry.calc_spacegroup"><code>SymmetryReduceBZ.Symmetry.calc_spacegroup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">calc_spacegroup(real_latvecs,atom_types,atom_pos,coords,rtol,atol)</code></pre><p>Calculate the space group of a crystal structure.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as columns   of an array.</li><li><code>atom_types::AbstractArray{&lt;:Int,1}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractArray{&lt;:Real,2}</code>: the positions of atoms in the crystal   structure as columns of an array.</li><li><code>coords::String</code>: indicates the positions of the atoms are in &quot;lattice&quot; or   &quot;Cartesian&quot; coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>spacegroup</code>: the space group of the crystal structure. The first element of   <code>spacegroup</code> is a list of fractional translations, and the second element is   a list of point operators. The translations are in Cartesian coordinates,   and the operators operate on points in Cartesian coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
real_latvecs = Array([1 0; 2 1]&#39;)
atom_types = [0, 1]
atom_pos = Array([0 0; 0.5 0.5]&#39;)
coords = &quot;Cartesian&quot;
SymmetryReduceBZ.Symmetry.calc_spacegroup(real_latvecs,atom_types,atom_pos,
	coords)
# output
(Any[[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],
[0.0, 0.0], [0.0, 0.0]], Any[[0.0 -1.0; -1.0 0.0], [0.0 -1.0; 1.0 0.0],
[-1.0 0.0; 0.0 -1.0], [1.0 0.0; 0.0 -1.0], [-1.0 0.0; 0.0 1.0],
[1.0 0.0; 0.0 1.0], [0.0 1.0; -1.0 0.0], [0.0 1.0; 1.0 0.0]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L352-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.inhull" href="#SymmetryReduceBZ.Symmetry.inhull"><code>SymmetryReduceBZ.Symmetry.inhull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inhull(point, chull, rtol, atol)</code></pre><p>Check if a point lies within a convex hull (including the boundaries).</p><p><strong>Arguments</strong></p><ul><li><code>point::AbstractArray{&lt;:Real,1}</code>: a point in Cartesian coordinates.</li><li><code>chull::Chull{Float64}</code>: a convex hull in 2D or 3D.</li><li><code>rtol::Real=sqrt(eps(float(maximum(flatten(chull.points)))))</code>: a relative</li></ul><pre><code class="language-none">tolerance for floating point comparisons. Needed when a point is on the
boundary of the convex hull.</code></pre><ul><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>inside::Bool</code>: if true, the point lies within the convex hull.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">real_latvecs = [1 0; 0 2]
atomtypes=[0]
atompos=Array([0 0]&#39;)
bzformat=&quot;convex hull&quot;
coords=&quot;Cartesian&quot;
convention=&quot;ordinary&quot;
makeprim=false
bz=calc_bz(real_latvecs, atomtypes,atompos,coords,bzformat,makeprim,convention)

point = [0,0]
inhull(point,bz)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L223-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.make_primitive" href="#SymmetryReduceBZ.Symmetry.make_primitive"><code>SymmetryReduceBZ.Symmetry.make_primitive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_primitive(real_latvecs,atom_types,atom_pos,coords,rtol,atol)</code></pre><p>Make a given unit cell primitive.</p><p>This is a Julia translation of the function by the same in     https://github.com/msg-byu/symlib.</p><p><strong>Arguments</strong></p><ul><li><code>real_latvecs::AbstractArray{&lt;:Real,2}</code>: the basis of the lattice as columns   of an array.</li><li><code>atom_types::AbstractArray{&lt;:Int,1}</code>: a list of atom types as integers.</li><li><code>atom_pos::AbstractArray{&lt;:Real,2}</code>: the positions of atoms in the crystal   structure as columns of an array.</li><li><code>coords::String</code>: indicates the positions of the atoms are in &quot;lattice&quot; or   &quot;Cartesian&quot; coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(real_latvecs))))</code> a relative tolerance for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>prim_types::AbstractArray{&lt;:Int,1}</code>: a list of atom types as integers in the   primitive unit cell.</li><li><code>prim_pos::AbstractArray{&lt;:Real,2}</code>: the positions of the atoms in in the   crystal structure as columns of an array.</li><li><code>prim_latvecs::AbstractArray{&lt;:Real,2}</code>: the primitive lattice vectors as   columns of an array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">import SymmetryReduceBZ.Lattices: genlat_CUB
import SymmetryReduceBZ.Symmetry: make_primitive
a = 1.0
real_latvecs = genlat_CUB(a)
atom_types = [0,0]
atom_pos = Array([0 0 0; 0.5 0.5 0.5]&#39;)
ibzformat = &quot;convex hull&quot;
coords = &quot;Cartesian&quot;
convention = &quot;ordinary&quot;
make_primitive(real_latvecs, atom_types, atom_pos, coords)
# output
([0], [0.0; 0.0; 0.0], [1.0 0.0 0.5; 0.0 1.0 0.5; 0.0 0.0 0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L672-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_BZ" href="#SymmetryReduceBZ.Symmetry.mapto_BZ"><code>SymmetryReduceBZ.Symmetry.mapto_BZ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapto_BZ(kpoint,recip_latvecs,inv_latvecs,coords,rtol,atol)</code></pre><p>Map a k-point to a translationally equivalent point within the Brillouin zone.</p><p><strong>Arguments</strong></p><ul><li><code>kpoint::AbstractArray{&lt;:Real,1}</code>: a single <em>k</em>-point in lattice or Cartesian   coordinates.</li><li><code>recip_latvecs::AbstractArray{&lt;:Real,2}</code>: the reciprocal lattice vectors as   columns of an array.</li><li><code>inv_latvecs::AbstractArray{&lt;:Real,2}</code>: the inverse matrix of the reciprocal   lattice vectors.</li><li><code>coords::String</code>: the coordinates of the given <em>k</em>-point, either &quot;lattice&quot;</li></ul><pre><code class="language-none">or &quot;Cartesian&quot;. The *k*-point returned will be in the same coordinates.</code></pre><ul><li><code>rtol::Real=sqrt(eps(float(maximum(recip_latvecs))))</code>: a relative tolerance</li></ul><pre><code class="language-none">for floating point comparisons. Finite precision errors creep in when `pt`
is transformed to lattice coordinates because the transformation requires
calculating a matrix inverse. The components of the *k*-point in lattice
coordinates are checked to ensure that values close to 1 are equal to 1.</code></pre><ul><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>bz_point::AbtractArray{&lt;:Real,1}</code>: the symmetrically equivalent <em>k</em>-point</li></ul><pre><code class="language-none">within the Brillouin zone in either lattice or Cartesian coordinates,
depending on the coordinates specified.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">import LinearAlgebra: inv
recip_latvecs = [1 0 0; 0 1 0; 0 0 1]
inv_latvecs = inv(recip_latvecs)
kpoint = [2, 3, 2]
coords = &quot;Cartesian&quot;
mapto_BZ(kpoint, recip_latvecs, inv_latvecs, coords)
# output
3-element Array{Real,1}:
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L143-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_IBZ" href="#SymmetryReduceBZ.Symmetry.mapto_IBZ"><code>SymmetryReduceBZ.Symmetry.mapto_IBZ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapto_IBZ(kpoint,recip_latvecs,inv_rlatvecs,ibz,pointgroup,coords,rtol,atol)</code></pre><p>Map a point to a symmetrically equivalent point within the IBZ.</p><p><strong>Arguments</strong></p><ul><li><code>kpoint::AbstractArray{&lt;:Real,1}</code>: a <em>k</em>-point in 2D or 3D in Cartesian</li></ul><pre><code class="language-none">coordinates.</code></pre><ul><li><code>recip_latvecs::AbstractArray{&lt;:Real,2}</code>: the reciprocal lattice vectors as</li></ul><pre><code class="language-none">columns of a an array.</code></pre><ul><li><code>inv_rlatvecs::AbstractArray{&lt;:Real,2}</code>: the inverse of the square array</li></ul><pre><code class="language-none">`recip_latvecs`.</code></pre><ul><li><code>ibz::Chull{Float64}</code>: the irreducible Brillouin zone as as a convex hull</li></ul><pre><code class="language-none">objects from `QHull`.</code></pre><ul><li><code>pointgroup::Array{Array{Float64,2},1}</code>: a list of point symmetry operators</li></ul><pre><code class="language-none">in matrix form that operate on points from the left.</code></pre><ul><li><code>coords::String</code>: the coordinates the <em>k</em>-point is in. Options are &quot;lattice&quot;</li></ul><pre><code class="language-none">and &quot;Cartesian&quot;. The *k*-point within the IBZ is returned in the same
coordinates.</code></pre><ul><li><code>rtol::Real=sqrt(eps(float(maximum(recip_latvecs))))</code>: a relative tolerance</li></ul><pre><code class="language-none">for floating point comparisons. The *k*-point is first mapped the unit cell
and `rtol` is used when comparing components of the *k*-point to 1. It is
also used for comparing floats to zero when checking if the point lies
within `ibz`.</code></pre><ul><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons. This</li></ul><pre><code class="language-none">is used everywhere `rtol` is used.</code></pre><p><strong>Returns</strong></p><ul><li><code>rot_point::AbstractArray{Real,1}</code>: a symmetrically equivalent <em>k</em>-point to</li></ul><pre><code class="language-none">`kpoint` within the irreducible Brillouin zone in the same coordinates as
`coords`.</code></pre><p>#Examples</p><pre><code class="language-julia">import SymmetryReduceBZ.Lattices: get_recip_latvecs
import SymmetryReduceBZ.Symmetry: calc_pointgroup, calc_ibz, mapto_IBZ

real_latvecs = [1 0; 0 2]
convention=&quot;ordinary&quot;
recip_latvecs = get_recip_latvecs(real_latvecs,convention)
inv_rlatvecs = inv(recip_latvecs)
atomtypes=[0]
atompos=Array([0 0]&#39;)
coords=&quot;Cartesian&quot;
ibzformat=&quot;convex hull&quot;
makeprim=false

ibz=calc_ibz(real_latvecs, atomtypes,atompos,coords,ibzformat,makeprim,convention)
pg = calc_pointgroup(real_latvecs)
kpoint = [2,3]
ibz_point = mapto_IBZ(kpoint,recip_latvecs,inv_rlatvecs,ibz,pg,coords)
# output
2-element Array{Real,1}:
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L275-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Symmetry.mapto_unitcell" href="#SymmetryReduceBZ.Symmetry.mapto_unitcell"><code>SymmetryReduceBZ.Symmetry.mapto_unitcell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapto_unitcell(pt,latvecs,inv_latvecs,coords,rtol,atol)</code></pre><p>Map a point to the first unit cell.</p><p><strong>Arguments</strong></p><ul><li><code>pt::AbstractArray{&lt;:Real,1}</code>: a point in lattice or Cartesian coordinates.</li><li><code>latvecs::AbstractArray{&lt;:Real,2}</code>: the basis vectors of the lattice as   columns of an array.</li><li><code>inv_latvecs::AbstractArray{&lt;:Real,2}</code>: the inverse of the matrix of that   contains the lattice vectors.</li><li><code>coords::String</code>: indicates whether <code>pt</code> is in &quot;Cartesian&quot; or &quot;lattice&quot;   coordinates.</li><li><code>rtol::Real=sqrt(eps(float(maximum(inv_latvecs))))</code>: a relative tolerance for   floating point comparisons. Finite precision errors creep up when <code>pt</code> is   transformed to lattice coordinates because the transformation requires   calculating a matrix inverse. The components of the point in lattice   coordinates are checked to ensure that values close to 1 are equal to 1.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,1}</code>: a translationally equivalent point to <code>pt</code> in the   first unit cell in the same coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
real_latvecs = [0 1 2; 0 -1 1; 1 0 0]
inv_latvecs=inv(real_latvecs)
pt=[1,2,3.2]
coords = &quot;Cartesian&quot;
SymmetryReduceBZ.Symmetry.mapto_unitcell(pt,real_latvecs,inv_latvecs,coords)
# output
3-element Array{Float64,1}:
 0.0
 0.0
 0.20000000000000018</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Symmetry.jl#L88-L126">source</a></section></article><h3 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.affine_trans-Tuple{AbstractArray{var&quot;#s158&quot;,2} where var&quot;#s158&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.affine_trans-Tuple{AbstractArray{var&quot;#s158&quot;,2} where var&quot;#s158&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.affine_trans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">affine_trans(pts)</code></pre><p>Calculate the affine transformation that maps the points to the xy-plane.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractArray{&lt;:Real,2}</code>: an array of Cartesian points as the columns   of a 2D array. The points must all lie on a plane in 3D.</li></ul><p><strong>Returns</strong></p><ul><li><code>M::AbstractArray{&lt;:Real,2}</code>: the affine transformation matrix that operates   on points in homogeneous coordinates from the left.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
pts = [0.5 0.5 0.5; 0.5 -0.5 0.5; -0.5 0.5 0.5; -0.5 -0.5 0.5]&#39;
SymmetryReduceBZ.Utilities.affine_trans(pts)
# output
4×4 Array{Float64,2}:
  0.0  -1.0   0.0  0.5
 -1.0   0.0   0.0  0.5
  0.0   0.0  -1.0  0.5
  0.0   0.0   0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L10-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.contains" href="#SymmetryReduceBZ.Utilities.contains"><code>SymmetryReduceBZ.Utilities.contains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contains(pt,pts,rtol,atol)</code></pre><p>Check if an array of points contains a point.</p><p><strong>Arguments</strong></p><ul><li><code>pt::AbstractArray{&lt;:Real,1}</code>: a 1D array of reals</li><li><code>pts::AbstractArray{&lt;:Real,2}</code>: a 2D array of reals. Coordinates of points   are the columns of the array.</li><li><code>rtol::Real=sqrt(eps(float(maximum(pts))))</code>: a relative tolerance for floating   point comparisons</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: a boolean that indicates the presence or absence of <code>pt</code> in <code>pts</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">import SymmetryReduceBZ.Utilities: contains
pts = Array([1 2; 2 3; 3 4; 4 5]&#39;)
pt = [1,2]
contains(pt,pts)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L52-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.contains" href="#SymmetryReduceBZ.Utilities.contains"><code>SymmetryReduceBZ.Utilities.contains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contains(array,arrays,rtol,atol)</code></pre><p>Check if an array of arrays contains an array.</p><p><strong>Arguments</strong></p><ul><li><code>array</code>: an array of reals or arbitrary dimension.</li><li><code>arrays</code>: a abstract array of reals of arbitrary dimension.</li><li><code>rtol::Real=sqrt(eps(float(maximum(pts))))</code>: a relative tolerance for floating   point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: a boolean that indicates the presence of absence of <code>array</code> in   <code>arrays</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">import SymmetryReduceBZ.Utilities: contains
arrays = [[1 2; 2 3], [2 3; 4 5]]
array = [1 2; 2 3]
contains(array, arrays)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L83-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.edgelengths" href="#SymmetryReduceBZ.Utilities.edgelengths"><code>SymmetryReduceBZ.Utilities.edgelengths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edgelengths(basis,radius)</code></pre><p>Calculate the edge lengths of a parallelepiped circumscribed by a sphere.</p><p><strong>Arguments</strong></p><ul><li><code>basis::Array{&lt;:Real,2}</code>: a 2x2 or 3x3 matrix whose columns give the   parallelogram or parallelepiped directions, respectively.</li><li><code>radius::Real</code>: the radius of the sphere.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerace for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point   comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>[la,lb,lc]::Array{Float64,1}</code>: a list of parallelepiped lengths.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis=Array([1. 0. 0.; 0. 1. 0.; 0. 0. 1.])
radius=3.0
SymmetryReduceBZ.Utilities.edgelengths(basis,radius)
# output
3-element Array{Float64,1}:
 3.0
 3.0
 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L115-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Any}" href="#SymmetryReduceBZ.Utilities.get_uniquefacets-Tuple{Any}"><code>SymmetryReduceBZ.Utilities.get_uniquefacets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_uniquefacets(ch)</code></pre><p>Calculate the unique facets of a convex hull object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.mapto_xyplane-Tuple{AbstractArray{var&quot;#s159&quot;,2} where var&quot;#s159&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.mapto_xyplane-Tuple{AbstractArray{var&quot;#s159&quot;,2} where var&quot;#s159&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.mapto_xyplane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mapto_xyplane(pts)</code></pre><p>Map Cartesian points embedded in 3D on a plane to the xy-plane embedded in 2D.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractArray{&lt;:Real,2}</code>: Cartesian points in 3D as columns of a 2D   array.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code>: Cartesian points in 2D as columns of a 2D array.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
pts = [0.5 -0.5 0.5; 0.5 -0.5 -0.5; 0.5 0.5 -0.5; 0.5 0.5 0.5]&#39;
SymmetryReduceBZ.Utilities.mapto_xyplane(pts)
# output
2×4 Array{Float64,2}:
 0.0  1.0  1.0  0.0
 0.0  0.0  1.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L208-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.remove_duplicates" href="#SymmetryReduceBZ.Utilities.remove_duplicates"><code>SymmetryReduceBZ.Utilities.remove_duplicates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_duplicates(points,rtol,atol)</code></pre><p>Remove duplicate points from an array.</p><p><strong>Arguments</strong></p><ul><li><code>points::AbstractArray{&lt;:Real,2}</code>: the points are columns of a 2D array.</li><li><code>rtol::Real=sqrt(eps(float(maximum(flatten(points)))))</code>: a relative tolerance   for floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolume tolerance for floating point comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>uniquepts::AbstractArray{&lt;:Real,2}</code>: a 2D array of unique points as columns.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
points=Array([1 2; 2 3; 3 4; 1 2]&#39;)
SymmetryReduceBZ.Utilities.remove_duplicates(points)
# output
2×3 Array{Int64,2}:
 1  2  3
 2  3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L410-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sample_circle" href="#SymmetryReduceBZ.Utilities.sample_circle"><code>SymmetryReduceBZ.Utilities.sample_circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_circle(basis,radius,offset,rtol,atol)</code></pre><p>Sample uniformly within a circle centered about a point.</p><p><strong>Arguments</strong></p><ul><li><code>basis::Array{&lt;:Real,2}</code>: a 2x2 matrix whose columns are the grid generating   vectors.</li><li><code>radius::Real</code>: the radius of the circle.</li><li><code>offset::Array{&lt;:Real,1}=[0.,0.]</code>: the xy-coordinates of the center of the   circle.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerace for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point   comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>pts::Array{Float64,2}</code> a matrix whose columns are sample points in Cartesian   coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis=Array([1. 0.; 0. 1.]&#39;)
radius=1.0
offset=[0.,0.]
SymmetryReduceBZ.Utilities.sample_circle(basis,radius,offset)
# output
2×5 Array{Float64,2}:
  0.0  -1.0  0.0  1.0  0.0
 -1.0   0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L237-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sample_sphere" href="#SymmetryReduceBZ.Utilities.sample_sphere"><code>SymmetryReduceBZ.Utilities.sample_sphere</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample_sphere(basis,radius,offset,rtol,atol)</code></pre><p>Sample uniformly within a circle centered about a point.</p><p><strong>Arguments</strong></p><ul><li><code>basis::Array{&lt;:Real,2}</code>: a 3x3 matrix whose columns are the grid generating   vectors.</li><li><code>radius::Real</code>: the radius of the sphere.</li><li><code>offset::Array{&lt;:Real,1}=[0.,0.]</code>: the xy-coordinates of the center of the   circle.</li><li><code>rtol::Real=sqrt(eps(float(radius)))</code>: a relative tolerace for   floating point comparisons.</li><li><code>atol::Real=0.0</code>: an absolute tolerance for floating point   comparisons.</li></ul><p><strong>Returns</strong></p><ul><li><code>pts::Array{Float64,2}</code> a matrix whose columns are sample points in Cartesian   coordinates.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
basis=Array([1. 0. 0.; 0. 1. 0.; 0. 0. 1.])
radius=1.0
offset=[0.,0.,0.]
SymmetryReduceBZ.Utilities.sample_sphere(basis,radius,offset)
# output
3×7 Array{Float64,2}:
  0.0   0.0  -1.0  0.0  1.0  0.0  0.0
  0.0  -1.0   0.0  0.0  0.0  1.0  0.0
 -1.0   0.0   0.0  0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L294-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.shoelace-Tuple{Any}" href="#SymmetryReduceBZ.Utilities.shoelace-Tuple{Any}"><code>SymmetryReduceBZ.Utilities.shoelace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shoelace(vertices)</code></pre><p>Calculate the area of a polygon with the shoelace algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>vertices::AbstractArray{&lt;:Real,2}</code>: the xy-coordinates of the vertices   of the polygon as the columns of a 2D array.</li></ul><p><strong>Returns</strong></p><ul><li><code>&lt;:Real</code>: the area of the polygon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L352-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymmetryReduceBZ.Utilities.sortpts_perm-Tuple{AbstractArray{var&quot;#s158&quot;,2} where var&quot;#s158&quot;&lt;:Real}" href="#SymmetryReduceBZ.Utilities.sortpts_perm-Tuple{AbstractArray{var&quot;#s158&quot;,2} where var&quot;#s158&quot;&lt;:Real}"><code>SymmetryReduceBZ.Utilities.sortpts_perm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sortpts_perm(pts)</code></pre><p>Calculate the permutation vector that sorts Cartesian points embedded in 3D that     lie on a plane (counter)clockwise with respect to the average of all points.</p><p><strong>Arguments</strong></p><ul><li><code>pts::AbstractArray{&lt;:Real,2}</code>: Cartesian points embedded in 3D that all lie   on a plane. The points are columns of a 2D array.</li></ul><p><strong>Returns</strong></p><ul><li><code>perm::AbstractArray{&lt;:Real,1}</code>: the permutation vector that orders the points   clockwise or counterclockwise.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using SymmetryReduceBZ
pts = [0.5 -0.5 0.5; 0.5 -0.5 -0.5; 0.5 0.5 -0.5; 0.5 0.5 0.5]&#39;
perm=SymmetryReduceBZ.Utilities.sortpts_perm(pts)
pts[:,perm]
# output
3×4 Array{Float64,2}:
  0.5  0.5   0.5   0.5
  0.5  0.5  -0.5  -0.5
 -0.5  0.5   0.5  -0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jerjorg/SymmetryReduceBZ.jl/blob/e457348094c44c9bfb020fa35e6f95d576e30481/src/Utilities.jl#L371-L397">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Usage/">User guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 10 February 2021 06:30">Wednesday 10 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
